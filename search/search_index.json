{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pytest_cache_assert \u2693\ufe0e Cache assertion data to simplify regression testing of complex serializable data Installation \u2693\ufe0e poetry add pytest_assert_check --dev Usage \u2693\ufe0e The primary use case of this package is regression testing of large, serializable dictionaries, such as from an API under development. You may have parameterized test cases where you need to assert that the created dictionary stays the same, but you don\u2019t want to manually generate the expected fields and values to compare. Instead you can capture a snapshot of the serialized data and cache the result then use the cached data to check for consistency in repeated test runs. The cached files should be checked into version control, which can be very useful as documentation This package can minimize test case logic, while improving regression testing thoroughness This project was heavily inspired by the excellent pytest-recording Alternatives \u2693\ufe0e pytest-recording : this is the package I use and highly recommend for recording and replaying external API communication so that API requests only need to be made once for unit testing (i.e. recording API responses from Github\u2019s API called from a test suite) pytest-snapshot : I only found this package after already releasing a 1.0.0 version of pytest_assert_cache . This package can be more configurable with a user-specified serializer and might be a good alternative. See their documentation for more info snapshottest : This was another find after releasing a 1.0.0 version and would probably be a good alterantive for most users pytest-snapshot is much more configurable, has many more users, and is a better name I really like the ability to quickly regenerate the cached files with \u2013snapshot-update There is some interesting discussion on how best to handle fields that change between tests dirty-equals : broadly check values (i.e. assert result == {'counter': IsPositiveInt, ...} , etc.) rather than accessing and checking each field individual, which makes test easier to write and output errors easier to review Basic Example \u2693\ufe0e You\u2019ve created a new project called package_a with one file package_a/source_file.py and test tests/test_file.py \"\"\"package_a/source_file.py\"\"\" import sys from datetime import datetime from typing import Any , Dict , List , Optional from beartype import beartype from pydantic import BaseModel class User ( BaseModel ): # noqa: H601 \"\"\"Example from pydantic documentation.\"\"\" id : int # noqa: A003,VNE003 name = 'John Doe' signup_ts : Optional [ datetime ] = None friends : List [ int ] = [] @beartype def create_data ( name : str ) -> Dict : \"\"\"Arbitrary function that returns a dictionary. This demonstration uses pydantic, but any dictionary can be tested! \"\"\" return User ( id = sys . maxsize , name = name ) . dict () \"\"\"tests/test_file.py\"\"\" import pytest from package_a.source_file import create_data @pytest . mark . parametrize ( 'name' , [ 'Test Name 1' , 'Test Name 2' ]) def test_create_data ( name , assert_against_cache ): \"\"\"Basic test of create_data().\"\"\" result = create_data ( name = name ) # One could manually create the expected dictionary cache = { 'id' : 9223372036854775807 , 'signup_ts' : None , 'friends' : [], 'name' : name } assert result == cache # ---------------------------------------------------------------------------------- # Or utilize the pytest_cache_assert fixture to compare against the last cached version assert_against_cache ( result ) pytest_cache_assert will automatically create: tests/cache-assert/source_file/test_file/test_create_data-[Test Name 1].json (and test_create_data[Test Name 2].json ) for each of the parameters when first run by caching the result . Below is the example for test_create_data-[Test Name 1].json { \"_info\" : [ { \"func_args\" : { \"name\" : \"Test Name 1\" }, \"test_file\" : \"test_readme.py\" , \"test_name\" : \"test_create_data\" } ], \"_json\" : { \"friends\" : [], \"id\" : 9223372036854775807 , \"name\" : \"Test Name 1\" , \"signup_ts\" : null } } The cached JSON files must be checked into version control and if needed, can be manually edited or deleted so that they will be regenerated when the test suite is next run More Examples \u2693\ufe0e In your cached dictionary, you may have variable values with more complex logic to verify, such as dates, UUIDs, etc. These can be selectively ignored, matched-if-null, or some other user-specified check: \"\"\"tests/test_readme_more.py.\"\"\" from contextlib import suppress from datetime import datetime , timedelta from uuid import uuid4 import pytest from pytest_cache_assert import AssertRule , Wild , check_suppress , check_type def test_assert_against_cache_key_rules ( assert_against_cache ): \"\"\"Demonstrate use of `assert_rules`.\"\"\" now = datetime . now () cached_data = { 'date' : str ( now ), 'nested' : { 'uuid' : str ( uuid4 ())}, 'ignored' : { 'a' : 1 , 'b' : 2 }, } test_data = { 'date' : str ( now + timedelta ( hours = 3 )), 'nested' : { 'uuid' : str ( uuid4 ())}, 'ignored' : { 'recursively' : { 'a' : { 'b' : { 'c' : 1 }}}}, } with suppress ( AssertionError ): # Ensures that the cache file has been created assert_against_cache ( cached_data ) assert_rules = [ # To ignore values for 'ignored.a' and 'ignored.b', create a rule # Here, we use the wildcard for dictionary keys AssertRule . build_re ( pattern = [ 'ignored' , Wild . recur ()], func = check_suppress ), # Instead of suppressing, the type of data could be resolved and compared # This is useful for datetime or UUID values where we expect variability AssertRule ( pattern = 'date' , func = check_type ), AssertRule . build_re ( pattern = [ 'nested' , 'uuid' ], func = check_type ), # Any \"func\" with arguments 'old' and 'new' can be used as a rule ] # Without assert rules, an AssertionError is raised with pytest . raises ( AssertionError ): assert_against_cache ( test_data ) # But, with the custom logic, the cache assertion check will succeed assert_against_cache ( test_data , assert_rules = assert_rules ) Even More Examples \u2693\ufe0e For more example code, see the scripts directory or the tests . Customization ( beta ) \u2693\ufe0e Note: this feature is to be considered beta and may change, however, I will do my best to keep the same interfaces For 2.0.0, pytest_cache_assert was refactored to be more easily customizable with configuration options for not just the cache directory, but also for a way to override how files are named and to override how the cached test data is serialized and validated. With these configuration options, users or 3rd party packages can replace the default package behavior, such as changing the file format for data serialization ( yaml , jsonlines , etc.) and/or specifying a different serialization logic. All configuration options are available by creating a cache_assert_config fixture with the provided implementations. See AssertConfig in plugin.py for configuration options and more information always_write : Always write to the cached file so that diffs can be examined in the user\u2019s VCS. cache_dir_rel_path : String relative directory from tests/ . Default resolves to tests/assert-cache/ . cache_store : Configurable class for managing the cache representation. Default is local JSON. converters : register functions that handle conversion of unhandled types, such as pandas DataFrames validator : Custom validator for identifying and summarizing the deviations from the cache. import pytest from pytest_cache_assert.plugin import AssertConfig @pytest . fixture ( scope = 'module' ) def cache_assert_config (): return AssertConfig ( cache_dir_rel_path = 'custom/cache/dir' ) Project Status \u2693\ufe0e See the Open Issues and/or the CODE_TAG_SUMMARY . For release history, see the CHANGELOG . Planned Global Configuration Options \u2693\ufe0e These are ideas for future options that are not currently implemented, but could be if there is enough interest: PLANNED: Provide CLI arguments like pytest-recording ( request.config.getoption(\"--record-mode\") or \"none\" ) for one-time changes to configuration PLANNED: Consider filters to prevent secrets from being cached: filter_headers=[['authorization', 'id'], ['authorization', 'cookies']] (Although, you should be using a pre-commit hook and formatting the dict before passing to to the cache) TODO: Add tips from Jest on best practices \u2013 treat snapshots as code, etc. Contributing \u2693\ufe0e We welcome pull requests! For your pull request to be accepted smoothly, we suggest that you first open a GitHub issue to discuss your idea. For resources on getting started with the code base, see the below documentation: DEVELOPER_GUIDE STYLE_GUIDE Code of Conduct \u2693\ufe0e We follow the Contributor Covenant Code of Conduct . Open Source Status \u2693\ufe0e We try to reasonably meet most aspects of the \u201cOpenSSF scorecard\u201d from Open Source Insights Responsible Disclosure \u2693\ufe0e If you have any security issue to report, please contact the project maintainers privately. You can reach us at dev.act.kyle@gmail.com . License \u2693\ufe0e LICENSE","title":"pytest_cache_assert"},{"location":"#pytest_cache_assert","text":"Cache assertion data to simplify regression testing of complex serializable data","title":"pytest_cache_assert"},{"location":"#installation","text":"poetry add pytest_assert_check --dev","title":"Installation"},{"location":"#usage","text":"The primary use case of this package is regression testing of large, serializable dictionaries, such as from an API under development. You may have parameterized test cases where you need to assert that the created dictionary stays the same, but you don\u2019t want to manually generate the expected fields and values to compare. Instead you can capture a snapshot of the serialized data and cache the result then use the cached data to check for consistency in repeated test runs. The cached files should be checked into version control, which can be very useful as documentation This package can minimize test case logic, while improving regression testing thoroughness This project was heavily inspired by the excellent pytest-recording","title":"Usage"},{"location":"#alternatives","text":"pytest-recording : this is the package I use and highly recommend for recording and replaying external API communication so that API requests only need to be made once for unit testing (i.e. recording API responses from Github\u2019s API called from a test suite) pytest-snapshot : I only found this package after already releasing a 1.0.0 version of pytest_assert_cache . This package can be more configurable with a user-specified serializer and might be a good alternative. See their documentation for more info snapshottest : This was another find after releasing a 1.0.0 version and would probably be a good alterantive for most users pytest-snapshot is much more configurable, has many more users, and is a better name I really like the ability to quickly regenerate the cached files with \u2013snapshot-update There is some interesting discussion on how best to handle fields that change between tests dirty-equals : broadly check values (i.e. assert result == {'counter': IsPositiveInt, ...} , etc.) rather than accessing and checking each field individual, which makes test easier to write and output errors easier to review","title":"Alternatives"},{"location":"#basic-example","text":"You\u2019ve created a new project called package_a with one file package_a/source_file.py and test tests/test_file.py \"\"\"package_a/source_file.py\"\"\" import sys from datetime import datetime from typing import Any , Dict , List , Optional from beartype import beartype from pydantic import BaseModel class User ( BaseModel ): # noqa: H601 \"\"\"Example from pydantic documentation.\"\"\" id : int # noqa: A003,VNE003 name = 'John Doe' signup_ts : Optional [ datetime ] = None friends : List [ int ] = [] @beartype def create_data ( name : str ) -> Dict : \"\"\"Arbitrary function that returns a dictionary. This demonstration uses pydantic, but any dictionary can be tested! \"\"\" return User ( id = sys . maxsize , name = name ) . dict () \"\"\"tests/test_file.py\"\"\" import pytest from package_a.source_file import create_data @pytest . mark . parametrize ( 'name' , [ 'Test Name 1' , 'Test Name 2' ]) def test_create_data ( name , assert_against_cache ): \"\"\"Basic test of create_data().\"\"\" result = create_data ( name = name ) # One could manually create the expected dictionary cache = { 'id' : 9223372036854775807 , 'signup_ts' : None , 'friends' : [], 'name' : name } assert result == cache # ---------------------------------------------------------------------------------- # Or utilize the pytest_cache_assert fixture to compare against the last cached version assert_against_cache ( result ) pytest_cache_assert will automatically create: tests/cache-assert/source_file/test_file/test_create_data-[Test Name 1].json (and test_create_data[Test Name 2].json ) for each of the parameters when first run by caching the result . Below is the example for test_create_data-[Test Name 1].json { \"_info\" : [ { \"func_args\" : { \"name\" : \"Test Name 1\" }, \"test_file\" : \"test_readme.py\" , \"test_name\" : \"test_create_data\" } ], \"_json\" : { \"friends\" : [], \"id\" : 9223372036854775807 , \"name\" : \"Test Name 1\" , \"signup_ts\" : null } } The cached JSON files must be checked into version control and if needed, can be manually edited or deleted so that they will be regenerated when the test suite is next run","title":"Basic Example"},{"location":"#more-examples","text":"In your cached dictionary, you may have variable values with more complex logic to verify, such as dates, UUIDs, etc. These can be selectively ignored, matched-if-null, or some other user-specified check: \"\"\"tests/test_readme_more.py.\"\"\" from contextlib import suppress from datetime import datetime , timedelta from uuid import uuid4 import pytest from pytest_cache_assert import AssertRule , Wild , check_suppress , check_type def test_assert_against_cache_key_rules ( assert_against_cache ): \"\"\"Demonstrate use of `assert_rules`.\"\"\" now = datetime . now () cached_data = { 'date' : str ( now ), 'nested' : { 'uuid' : str ( uuid4 ())}, 'ignored' : { 'a' : 1 , 'b' : 2 }, } test_data = { 'date' : str ( now + timedelta ( hours = 3 )), 'nested' : { 'uuid' : str ( uuid4 ())}, 'ignored' : { 'recursively' : { 'a' : { 'b' : { 'c' : 1 }}}}, } with suppress ( AssertionError ): # Ensures that the cache file has been created assert_against_cache ( cached_data ) assert_rules = [ # To ignore values for 'ignored.a' and 'ignored.b', create a rule # Here, we use the wildcard for dictionary keys AssertRule . build_re ( pattern = [ 'ignored' , Wild . recur ()], func = check_suppress ), # Instead of suppressing, the type of data could be resolved and compared # This is useful for datetime or UUID values where we expect variability AssertRule ( pattern = 'date' , func = check_type ), AssertRule . build_re ( pattern = [ 'nested' , 'uuid' ], func = check_type ), # Any \"func\" with arguments 'old' and 'new' can be used as a rule ] # Without assert rules, an AssertionError is raised with pytest . raises ( AssertionError ): assert_against_cache ( test_data ) # But, with the custom logic, the cache assertion check will succeed assert_against_cache ( test_data , assert_rules = assert_rules )","title":"More Examples"},{"location":"#even-more-examples","text":"For more example code, see the scripts directory or the tests .","title":"Even More Examples"},{"location":"#customization-beta","text":"Note: this feature is to be considered beta and may change, however, I will do my best to keep the same interfaces For 2.0.0, pytest_cache_assert was refactored to be more easily customizable with configuration options for not just the cache directory, but also for a way to override how files are named and to override how the cached test data is serialized and validated. With these configuration options, users or 3rd party packages can replace the default package behavior, such as changing the file format for data serialization ( yaml , jsonlines , etc.) and/or specifying a different serialization logic. All configuration options are available by creating a cache_assert_config fixture with the provided implementations. See AssertConfig in plugin.py for configuration options and more information always_write : Always write to the cached file so that diffs can be examined in the user\u2019s VCS. cache_dir_rel_path : String relative directory from tests/ . Default resolves to tests/assert-cache/ . cache_store : Configurable class for managing the cache representation. Default is local JSON. converters : register functions that handle conversion of unhandled types, such as pandas DataFrames validator : Custom validator for identifying and summarizing the deviations from the cache. import pytest from pytest_cache_assert.plugin import AssertConfig @pytest . fixture ( scope = 'module' ) def cache_assert_config (): return AssertConfig ( cache_dir_rel_path = 'custom/cache/dir' )","title":"Customization (beta)"},{"location":"#project-status","text":"See the Open Issues and/or the CODE_TAG_SUMMARY . For release history, see the CHANGELOG .","title":"Project Status"},{"location":"#planned-global-configuration-options","text":"These are ideas for future options that are not currently implemented, but could be if there is enough interest: PLANNED: Provide CLI arguments like pytest-recording ( request.config.getoption(\"--record-mode\") or \"none\" ) for one-time changes to configuration PLANNED: Consider filters to prevent secrets from being cached: filter_headers=[['authorization', 'id'], ['authorization', 'cookies']] (Although, you should be using a pre-commit hook and formatting the dict before passing to to the cache) TODO: Add tips from Jest on best practices \u2013 treat snapshots as code, etc.","title":"Planned Global Configuration Options"},{"location":"#contributing","text":"We welcome pull requests! For your pull request to be accepted smoothly, we suggest that you first open a GitHub issue to discuss your idea. For resources on getting started with the code base, see the below documentation: DEVELOPER_GUIDE STYLE_GUIDE","title":"Contributing"},{"location":"#code-of-conduct","text":"We follow the Contributor Covenant Code of Conduct .","title":"Code of Conduct"},{"location":"#open-source-status","text":"We try to reasonably meet most aspects of the \u201cOpenSSF scorecard\u201d from Open Source Insights","title":"Open Source Status"},{"location":"#responsible-disclosure","text":"If you have any security issue to report, please contact the project maintainers privately. You can reach us at dev.act.kyle@gmail.com .","title":"Responsible Disclosure"},{"location":"#license","text":"LICENSE","title":"License"},{"location":"docs/CHANGELOG/","text":"Unreleased \u2693\ufe0e Fix \u2693\ufe0e lower floor for pydantic version 3.0.6 (2022-10-19) \u2693\ufe0e Fix \u2693\ufe0e use Python 3.8.4 in CI 3.0.5 (2022-10-18) \u2693\ufe0e Fix \u2693\ufe0e remove dump of raw data in error message serialize bytes by passing to str serialize datetime by default Refactor \u2693\ufe0e reduce serializer complexity 3.0.4 (2022-10-08) \u2693\ufe0e Fix \u2693\ufe0e serialize all classes 3.0.3 (2022-10-06) \u2693\ufe0e Fix \u2693\ufe0e support arbitrary class serialization escape slashes in filepaths 3.0.2 (2022-10-04) \u2693\ufe0e Fix \u2693\ufe0e write metadata on first pass and autouse custom config pin maximum importlib-metadata for poetry publish 3.0.1 (2022-10-04) \u2693\ufe0e Fix \u2693\ufe0e register the AssertConfig when set only set override fixture once (in client tests) move generic memory serializer after type lookup support in-memory assertion checking handle serializing MagicMock Refactor \u2693\ufe0e type ignore comment removal switch to BaseModel and Protocol 3.0.0 (2022-09-25) \u2693\ufe0e Feat \u2693\ufe0e add missing Wild.recur initiaiize Wild class and rename KeyRule to AssertRule add serializer to store only relative paths begin supporting string-based KeyRules! even better error messages start switch from dictdiffer to deepdiff start migration of attrs to pydantic migrate from pendulum to arrow Fix \u2693\ufe0e replace punq with dictionary config for failing tests remove casts because they break the tests cast to Interface and not Protocol resolve list regex matching rules determine how to match regex for nested paths continue to update tests for change in pattern syntax start removing the Wildcards and legacy KeyRules Refactor \u2693\ufe0e considered ssort, but blocked by https://github.com/bwhmather/ssort/issues/70 last fix to restore mypy passing correct type ignore comments additional changes to pass type checks better support mypy add pydantic validators to custom types by default nest the caches by test file use suppress and remove loguru from pkg 2.0.0 (2022-05-01) \u2693\ufe0e Feat \u2693\ufe0e make numpy, pandas, and pydantic optionally serialize replace preconvert with custom registration logic #3 : implement always_write initialize configurable list of converters implement DictDifferValidator implement LocalJSONCacheStore initialize new customization features Fix \u2693\ufe0e on first write use test_data for comparison order of flow for parsing diff result handling s3 serialization and remove returns s3 serialization needs to catch all objects try to fix s3 serialization remove type checking entirely for str str can\u2019t be type-checked resolve local test failures after initial refactor commitizen changed Cerberus dependency version Refactor \u2693\ufe0e always override the converter support an optional Path replace TEST_DATA_TYPE with Any switch to preconvert internally encapsulate JSON logic combine into single CacheStore representation separate functional logic from state for DictDiff remove optional validator argument decouple AssertConfig from plugin 1.3.5 (2022-03-03) \u2693\ufe0e Fix \u2693\ufe0e another attempt at fixing edge case for unknown class 1.3.4 (2022-03-03) \u2693\ufe0e Fix \u2693\ufe0e class is only in the type string 1.3.3 (2022-03-03) \u2693\ufe0e Fix \u2693\ufe0e handle edge cases with serializing classes 1.3.2 (2022-03-01) \u2693\ufe0e Fix \u2693\ufe0e debug recursive serialization for diffing handle one-level of recursion in lists 1.3.1 (2022-02-27) \u2693\ufe0e Fix \u2693\ufe0e correct type validation of AssertConfig ser_rules 1.3.0 (2022-02-27) \u2693\ufe0e Feat \u2693\ufe0e improve configurability with AssertConfig introduce internally configurable punq 1.2.1 (2022-02-27) \u2693\ufe0e Fix \u2693\ufe0e support Paths 1.2.0 (2022-02-27) \u2693\ufe0e Feat \u2693\ufe0e WIP serializer to support functions copier update. Add Github Actions Fix \u2693\ufe0e implement serializer before diffing failing tests and run doit Refactor \u2693\ufe0e use next generation attrs syntax 1.1.1 (2022-02-18) \u2693\ufe0e Fix \u2693\ufe0e show the changelog on PyPi Refactor \u2693\ufe0e drop 2021 prefix on tags 1.1.0 (2022-02-18) \u2693\ufe0e Feat \u2693\ufe0e new assert_against_dict for in-memory comparison add support for comparing date-times Fix \u2693\ufe0e argument order issues in main datetime comparison logic Refactor \u2693\ufe0e use beartype\u2019s typing imports 1.0.0 (2021-11-02) \u2693\ufe0e Feat \u2693\ufe0e improve serialization Fix \u2693\ufe0e correctly implement an optional fixture make config fixture optional 1.0.0rc0 (2021-11-02) \u2693\ufe0e Feat \u2693\ufe0e support comparison of lists always write metadata as a list customizable cache directory support lists of dictionaries replace asterisk string with Wildcard enum support UUID in check_type Fix \u2693\ufe0e support dictionary keys with dots add CNAME for custom subdomain add missing check_imports file Refactor \u2693\ufe0e code cleanup & documentation updates simplify merge_metadata logic serialize the func_args metadata recursively improve code quality of _raw_diff 0.1.0 (2021-10-31) \u2693\ufe0e Feat \u2693\ufe0e implement key rules implement dictdiffer wrapper initialize decoupled differ and error message (WIP) use dictdiffer for quick fix for assertion messages resolve cache file name based on pytest metadata initial attempt at pytest plugin initialize package code and tests start with Readme (RDD) initialized project with copier Fix \u2693\ufe0e add tests and verify correctness of KeyRule use full name instead of custom indexing for cache use 2-spaces on JSON for pre-commit reduce stored metadata and check args re-run \u201cpoetry install\u201d after entrypoint changes Refactor \u2693\ufe0e rename checks to main rename check_assert to assert_against_cache & update README drop transformer and match_precision update notes and implementation plans","title":"Docs"},{"location":"docs/CHANGELOG/#unreleased","text":"","title":"Unreleased"},{"location":"docs/CHANGELOG/#fix","text":"lower floor for pydantic version","title":"Fix"},{"location":"docs/CHANGELOG/#306-2022-10-19","text":"","title":"3.0.6 (2022-10-19)"},{"location":"docs/CHANGELOG/#fix_1","text":"use Python 3.8.4 in CI","title":"Fix"},{"location":"docs/CHANGELOG/#305-2022-10-18","text":"","title":"3.0.5 (2022-10-18)"},{"location":"docs/CHANGELOG/#fix_2","text":"remove dump of raw data in error message serialize bytes by passing to str serialize datetime by default","title":"Fix"},{"location":"docs/CHANGELOG/#refactor","text":"reduce serializer complexity","title":"Refactor"},{"location":"docs/CHANGELOG/#304-2022-10-08","text":"","title":"3.0.4 (2022-10-08)"},{"location":"docs/CHANGELOG/#fix_3","text":"serialize all classes","title":"Fix"},{"location":"docs/CHANGELOG/#303-2022-10-06","text":"","title":"3.0.3 (2022-10-06)"},{"location":"docs/CHANGELOG/#fix_4","text":"support arbitrary class serialization escape slashes in filepaths","title":"Fix"},{"location":"docs/CHANGELOG/#302-2022-10-04","text":"","title":"3.0.2 (2022-10-04)"},{"location":"docs/CHANGELOG/#fix_5","text":"write metadata on first pass and autouse custom config pin maximum importlib-metadata for poetry publish","title":"Fix"},{"location":"docs/CHANGELOG/#301-2022-10-04","text":"","title":"3.0.1 (2022-10-04)"},{"location":"docs/CHANGELOG/#fix_6","text":"register the AssertConfig when set only set override fixture once (in client tests) move generic memory serializer after type lookup support in-memory assertion checking handle serializing MagicMock","title":"Fix"},{"location":"docs/CHANGELOG/#refactor_1","text":"type ignore comment removal switch to BaseModel and Protocol","title":"Refactor"},{"location":"docs/CHANGELOG/#300-2022-09-25","text":"","title":"3.0.0 (2022-09-25)"},{"location":"docs/CHANGELOG/#feat","text":"add missing Wild.recur initiaiize Wild class and rename KeyRule to AssertRule add serializer to store only relative paths begin supporting string-based KeyRules! even better error messages start switch from dictdiffer to deepdiff start migration of attrs to pydantic migrate from pendulum to arrow","title":"Feat"},{"location":"docs/CHANGELOG/#fix_7","text":"replace punq with dictionary config for failing tests remove casts because they break the tests cast to Interface and not Protocol resolve list regex matching rules determine how to match regex for nested paths continue to update tests for change in pattern syntax start removing the Wildcards and legacy KeyRules","title":"Fix"},{"location":"docs/CHANGELOG/#refactor_2","text":"considered ssort, but blocked by https://github.com/bwhmather/ssort/issues/70 last fix to restore mypy passing correct type ignore comments additional changes to pass type checks better support mypy add pydantic validators to custom types by default nest the caches by test file use suppress and remove loguru from pkg","title":"Refactor"},{"location":"docs/CHANGELOG/#200-2022-05-01","text":"","title":"2.0.0 (2022-05-01)"},{"location":"docs/CHANGELOG/#feat_1","text":"make numpy, pandas, and pydantic optionally serialize replace preconvert with custom registration logic #3 : implement always_write initialize configurable list of converters implement DictDifferValidator implement LocalJSONCacheStore initialize new customization features","title":"Feat"},{"location":"docs/CHANGELOG/#fix_8","text":"on first write use test_data for comparison order of flow for parsing diff result handling s3 serialization and remove returns s3 serialization needs to catch all objects try to fix s3 serialization remove type checking entirely for str str can\u2019t be type-checked resolve local test failures after initial refactor commitizen changed Cerberus dependency version","title":"Fix"},{"location":"docs/CHANGELOG/#refactor_3","text":"always override the converter support an optional Path replace TEST_DATA_TYPE with Any switch to preconvert internally encapsulate JSON logic combine into single CacheStore representation separate functional logic from state for DictDiff remove optional validator argument decouple AssertConfig from plugin","title":"Refactor"},{"location":"docs/CHANGELOG/#135-2022-03-03","text":"","title":"1.3.5 (2022-03-03)"},{"location":"docs/CHANGELOG/#fix_9","text":"another attempt at fixing edge case for unknown class","title":"Fix"},{"location":"docs/CHANGELOG/#134-2022-03-03","text":"","title":"1.3.4 (2022-03-03)"},{"location":"docs/CHANGELOG/#fix_10","text":"class is only in the type string","title":"Fix"},{"location":"docs/CHANGELOG/#133-2022-03-03","text":"","title":"1.3.3 (2022-03-03)"},{"location":"docs/CHANGELOG/#fix_11","text":"handle edge cases with serializing classes","title":"Fix"},{"location":"docs/CHANGELOG/#132-2022-03-01","text":"","title":"1.3.2 (2022-03-01)"},{"location":"docs/CHANGELOG/#fix_12","text":"debug recursive serialization for diffing handle one-level of recursion in lists","title":"Fix"},{"location":"docs/CHANGELOG/#131-2022-02-27","text":"","title":"1.3.1 (2022-02-27)"},{"location":"docs/CHANGELOG/#fix_13","text":"correct type validation of AssertConfig ser_rules","title":"Fix"},{"location":"docs/CHANGELOG/#130-2022-02-27","text":"","title":"1.3.0 (2022-02-27)"},{"location":"docs/CHANGELOG/#feat_2","text":"improve configurability with AssertConfig introduce internally configurable punq","title":"Feat"},{"location":"docs/CHANGELOG/#121-2022-02-27","text":"","title":"1.2.1 (2022-02-27)"},{"location":"docs/CHANGELOG/#fix_14","text":"support Paths","title":"Fix"},{"location":"docs/CHANGELOG/#120-2022-02-27","text":"","title":"1.2.0 (2022-02-27)"},{"location":"docs/CHANGELOG/#feat_3","text":"WIP serializer to support functions copier update. Add Github Actions","title":"Feat"},{"location":"docs/CHANGELOG/#fix_15","text":"implement serializer before diffing failing tests and run doit","title":"Fix"},{"location":"docs/CHANGELOG/#refactor_4","text":"use next generation attrs syntax","title":"Refactor"},{"location":"docs/CHANGELOG/#111-2022-02-18","text":"","title":"1.1.1 (2022-02-18)"},{"location":"docs/CHANGELOG/#fix_16","text":"show the changelog on PyPi","title":"Fix"},{"location":"docs/CHANGELOG/#refactor_5","text":"drop 2021 prefix on tags","title":"Refactor"},{"location":"docs/CHANGELOG/#110-2022-02-18","text":"","title":"1.1.0 (2022-02-18)"},{"location":"docs/CHANGELOG/#feat_4","text":"new assert_against_dict for in-memory comparison add support for comparing date-times","title":"Feat"},{"location":"docs/CHANGELOG/#fix_17","text":"argument order issues in main datetime comparison logic","title":"Fix"},{"location":"docs/CHANGELOG/#refactor_6","text":"use beartype\u2019s typing imports","title":"Refactor"},{"location":"docs/CHANGELOG/#100-2021-11-02","text":"","title":"1.0.0 (2021-11-02)"},{"location":"docs/CHANGELOG/#feat_5","text":"improve serialization","title":"Feat"},{"location":"docs/CHANGELOG/#fix_18","text":"correctly implement an optional fixture make config fixture optional","title":"Fix"},{"location":"docs/CHANGELOG/#100rc0-2021-11-02","text":"","title":"1.0.0rc0 (2021-11-02)"},{"location":"docs/CHANGELOG/#feat_6","text":"support comparison of lists always write metadata as a list customizable cache directory support lists of dictionaries replace asterisk string with Wildcard enum support UUID in check_type","title":"Feat"},{"location":"docs/CHANGELOG/#fix_19","text":"support dictionary keys with dots add CNAME for custom subdomain add missing check_imports file","title":"Fix"},{"location":"docs/CHANGELOG/#refactor_7","text":"code cleanup & documentation updates simplify merge_metadata logic serialize the func_args metadata recursively improve code quality of _raw_diff","title":"Refactor"},{"location":"docs/CHANGELOG/#010-2021-10-31","text":"","title":"0.1.0 (2021-10-31)"},{"location":"docs/CHANGELOG/#feat_7","text":"implement key rules implement dictdiffer wrapper initialize decoupled differ and error message (WIP) use dictdiffer for quick fix for assertion messages resolve cache file name based on pytest metadata initial attempt at pytest plugin initialize package code and tests start with Readme (RDD) initialized project with copier","title":"Feat"},{"location":"docs/CHANGELOG/#fix_20","text":"add tests and verify correctness of KeyRule use full name instead of custom indexing for cache use 2-spaces on JSON for pre-commit reduce stored metadata and check args re-run \u201cpoetry install\u201d after entrypoint changes","title":"Fix"},{"location":"docs/CHANGELOG/#refactor_8","text":"rename checks to main rename check_assert to assert_against_cache & update README drop transformer and match_precision update notes and implementation plans","title":"Refactor"},{"location":"docs/CODE_TAG_SUMMARY/","text":"Task Summary \u2693\ufe0e Auto-Generated by calcipy Type Comment Last Edit Source File FIXME Needs to support mkdocs: https://github.com/executablebooks/mdformat/issues/317 2022-09-17 .pre-commit-config.yaml:48 PLANNED newest version fails on positional argument errors: https://github.com/tox-dev/pyproject-fmt 2022-09-16 .pre-commit-config.yaml:68 TODO Update from: https://github.com/PyCQA/pylint/blob/main/examples/pylintrc 2022-09-16 .pylintrc:1 PLANNED Provide CLI arguments like pytest-recording ( request.config.getoption(\"--record-mode\") or \"none\" ) for one-time changes to configuration 2021-11-02 docs/README.md:199 PLANNED Consider filters to prevent secrets from being cached: filter_headers=[['authorization', 'id'], ['authorization', 'cookies']] (Although, you should be using a pre-commit hook and formatting the dict before passing to to the cache) 2022-09-25 docs/README.md:200 TODO Add tips from Jest on best practices \u2013 treat snapshots as code, etc. 2022-09-25 docs/README.md:201 PLANNED Faster to LBYL or EAFP? 2022-09-22 pytest_cache_assert/_check_assert/serializer.py:110 FIXME Replace with programmatic imports? Maybe explicit imports to check backward compatibility of public API? 2022-02-18 scripts/check_imports.py:7 TODO Add tests for additional types: st.binary(), etc. 2022-03-07 tests/test_main.py:160 Found code tags for FIXME (2), TODO (3), PLANNED (4)","title":"Task Summary"},{"location":"docs/CODE_TAG_SUMMARY/#task-summary","text":"Auto-Generated by calcipy Type Comment Last Edit Source File FIXME Needs to support mkdocs: https://github.com/executablebooks/mdformat/issues/317 2022-09-17 .pre-commit-config.yaml:48 PLANNED newest version fails on positional argument errors: https://github.com/tox-dev/pyproject-fmt 2022-09-16 .pre-commit-config.yaml:68 TODO Update from: https://github.com/PyCQA/pylint/blob/main/examples/pylintrc 2022-09-16 .pylintrc:1 PLANNED Provide CLI arguments like pytest-recording ( request.config.getoption(\"--record-mode\") or \"none\" ) for one-time changes to configuration 2021-11-02 docs/README.md:199 PLANNED Consider filters to prevent secrets from being cached: filter_headers=[['authorization', 'id'], ['authorization', 'cookies']] (Although, you should be using a pre-commit hook and formatting the dict before passing to to the cache) 2022-09-25 docs/README.md:200 TODO Add tips from Jest on best practices \u2013 treat snapshots as code, etc. 2022-09-25 docs/README.md:201 PLANNED Faster to LBYL or EAFP? 2022-09-22 pytest_cache_assert/_check_assert/serializer.py:110 FIXME Replace with programmatic imports? Maybe explicit imports to check backward compatibility of public API? 2022-02-18 scripts/check_imports.py:7 TODO Add tests for additional types: st.binary(), etc. 2022-03-07 tests/test_main.py:160 Found code tags for FIXME (2), TODO (3), PLANNED (4)","title":"Task Summary"},{"location":"docs/DEVELOPER_GUIDE/","text":"Developer Notes \u2693\ufe0e Local Development \u2693\ufe0e git clone https://github.com/kyleking/pytest_cache_assert.git cd pytest_cache_assert poetry install # See the available tasks poetry run doit list # Run the default task list (lint, auto-format, test coverage, etc.) poetry run doit --continue # Make code changes and run specific tasks as needed: poetry run doit run test Publishing \u2693\ufe0e For testing, create an account on TestPyPi . Replace ... with the API token generated on TestPyPi or PyPi respectively poetry config repositories.testpypi https://test.pypi.org/legacy/ poetry config pypi-token.testpypi ... poetry run doit run publish_test_pypi # If you didn't configure a token, you will need to provide your username and password to publish To publish to the real PyPi poetry config pypi-token.pypi ... poetry run doit run publish # For a full release, triple check the default tasks, increment the version, rebuild documentation (twice), and publish! poetry run doit run --continue poetry run doit run cl_bump lock document deploy_docs publish # For pre-releases use cl_bump_pre poetry run doit run cl_bump_pre -p rc poetry run doit run lock document deploy_docs publish Current Status \u2693\ufe0e File Statements Missing Excluded Coverage pytest_cache_assert/__init__.py 9 0 0 100.0% pytest_cache_assert/_check_assert/__init__.py 0 0 0 100.0% pytest_cache_assert/_check_assert/assert_config.py 24 0 0 100.0% pytest_cache_assert/_check_assert/assert_rules.py 87 8 0 90.8% pytest_cache_assert/_check_assert/cache_store.py 44 6 0 86.4% pytest_cache_assert/_check_assert/caching.py 36 0 0 100.0% pytest_cache_assert/_check_assert/config.py 27 0 0 100.0% pytest_cache_assert/_check_assert/constants.py 17 0 0 100.0% pytest_cache_assert/_check_assert/converter.py 6 0 0 100.0% pytest_cache_assert/_check_assert/differ.py 41 2 0 95.1% pytest_cache_assert/_check_assert/error_message.py 20 0 0 100.0% pytest_cache_assert/_check_assert/serializer.py 121 7 0 94.2% pytest_cache_assert/_check_assert/validator.py 23 3 0 87.0% pytest_cache_assert/main.py 27 0 0 100.0% pytest_cache_assert/plugin.py 45 2 0 95.6% Totals 527 28 0 94.7% Generated on: 2022-10-20","title":"Developer Notes"},{"location":"docs/DEVELOPER_GUIDE/#developer-notes","text":"","title":"Developer Notes"},{"location":"docs/DEVELOPER_GUIDE/#local-development","text":"git clone https://github.com/kyleking/pytest_cache_assert.git cd pytest_cache_assert poetry install # See the available tasks poetry run doit list # Run the default task list (lint, auto-format, test coverage, etc.) poetry run doit --continue # Make code changes and run specific tasks as needed: poetry run doit run test","title":"Local Development"},{"location":"docs/DEVELOPER_GUIDE/#publishing","text":"For testing, create an account on TestPyPi . Replace ... with the API token generated on TestPyPi or PyPi respectively poetry config repositories.testpypi https://test.pypi.org/legacy/ poetry config pypi-token.testpypi ... poetry run doit run publish_test_pypi # If you didn't configure a token, you will need to provide your username and password to publish To publish to the real PyPi poetry config pypi-token.pypi ... poetry run doit run publish # For a full release, triple check the default tasks, increment the version, rebuild documentation (twice), and publish! poetry run doit run --continue poetry run doit run cl_bump lock document deploy_docs publish # For pre-releases use cl_bump_pre poetry run doit run cl_bump_pre -p rc poetry run doit run lock document deploy_docs publish","title":"Publishing"},{"location":"docs/DEVELOPER_GUIDE/#current-status","text":"File Statements Missing Excluded Coverage pytest_cache_assert/__init__.py 9 0 0 100.0% pytest_cache_assert/_check_assert/__init__.py 0 0 0 100.0% pytest_cache_assert/_check_assert/assert_config.py 24 0 0 100.0% pytest_cache_assert/_check_assert/assert_rules.py 87 8 0 90.8% pytest_cache_assert/_check_assert/cache_store.py 44 6 0 86.4% pytest_cache_assert/_check_assert/caching.py 36 0 0 100.0% pytest_cache_assert/_check_assert/config.py 27 0 0 100.0% pytest_cache_assert/_check_assert/constants.py 17 0 0 100.0% pytest_cache_assert/_check_assert/converter.py 6 0 0 100.0% pytest_cache_assert/_check_assert/differ.py 41 2 0 95.1% pytest_cache_assert/_check_assert/error_message.py 20 0 0 100.0% pytest_cache_assert/_check_assert/serializer.py 121 7 0 94.2% pytest_cache_assert/_check_assert/validator.py 23 3 0 87.0% pytest_cache_assert/main.py 27 0 0 100.0% pytest_cache_assert/plugin.py 45 2 0 95.6% Totals 527 28 0 94.7% Generated on: 2022-10-20","title":"Current Status"},{"location":"docs/STYLE_GUIDE/","text":"Personal Style Guides \u2693\ufe0e Git \u2693\ufe0e We use Commitizen to manage both an auto-generated Changelog and incrementing the release version following semver . For both of these automated outputs to work well, please follow the Conventional Commits style, which is described in more detail below. Commitizen Types and Scopes \u2693\ufe0e type(scope): description Types fix : A bug fix feat : A new feature docs : Documentation-only changes (code comments, separate docs) style : Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons) perf : A code change that improves performance refactor : A change to production code that is not a fix , feat , or perf test : Adding missing or correcting existing tests build : Changes that affect the build system or external dependencies ci : Changes to our CI configuration files and scripts A ! can be used to indicate a breaking change ( refactor!: drop support for Node 6 ) SemVer Rules Based on commit type, the version will be auto-incremented: fix : PATCH // feat : MINOR // BREAKING CHANGE : MAJOR Scopes A Class, File name, Issue Number, other appropriate noun. As examples: build(poetry): bump requests to v3 or style(#32): add missing type annotations Tips What if a commit fits multiple types? Go back and make multiple commits whenever possible. Part of the benefit of Conventional Commits is the focus on more organized and intentional changes Use git rebase -i to fix commit names prior to merging if incorrect types/scopes are used Git Description Guidelines \u2693\ufe0e Commit message guidelines Full sentence with verb ( lowercase ) and concise description. Below are modified examples for Conventional Commits fix(roles): bug in admin role permissions feat(ui): implement new button design build(pip): upgrade package to remove vulnerabilities refactor: file structure to improve code readability perf(cli): rewrite methods feat(api): endpoints to implement new customer dashboard How to write a good commit message A diff will tell you what changed, but only the commit message can properly tell you why. Keep in mind: This has all been said before . From the seven rules of a great Git commit message: Try for 50 characters, but consider 72 the hard limit Use the body to explain what and why vs. how Issue Labels and Milestones \u2693\ufe0e Personal Guide For Issue Labels, see labels.yml Milestones Current Tasks : main milestone ( name could change based on a specific project, sprint, or month ) Next Tasks Blue Sky Research [Sane Github Labels](https://medium.com/@dave_lunny/sane-github-labels-c5d2e6004b63) and see [sensible-github-labels](https://github.com/Relequestual/sensible-github-labels) for full descriptions of each \u201cit is much more helpful to see the status and type of all issues at a glance.\u201d One of each: Status: \u2026 Abandoned, Accepted, Available, Blocked, Completed, In Progress, On Hold, Pending, Review Needed, Revision Needed Type: \u2026 Bug, Maintenance, Question, Enhancement Priority: \u2026 Critical, High, Medium, Low [Britecharts](https://britecharts.github.io/britecharts/github-labels.html) Status: \u2026 On Review \u2013 Request that we are pondering if including or not Needs Reproducing \u2013 For bugs that need to be reproduced in order to get fixed Needs Design \u2013 Feature that needs a design Ready to Go \u2013 Issue that has been defined and is ready to get started with In Progress \u2013 Issue that is being worked on right now. Completed \u2013 Finished feature or fix Type: \u2026 Bug \u2013 An unexpected problem or unintended behavior Feature \u2013 A new feature request Maintenance \u2013 A regular maintenance chore or task, including refactors, build system, CI, performance improvements Documentation \u2013 A documentation improvement task Question \u2013 An issue or PR that needs more information or a user question Not Included Priority: They would add complexity and overhead due to the discussions, but could help with the roadmap Technology Labels: It can create too much overhead, as properly tag with technologies all the issues could be time consuming [Ian Bicking Blog](https://www.ianbicking.org/blog/2014/03/use-github-issues-to-organize-a-project.html) Milestone Overview What are we doing right now? What aren\u2019t we doing right now? 2a. Stuff we\u2019ll probably do soon 2b. Stuff we probably won\u2019t do soon What aren\u2019t we sure about? Milestone Descriptions Stuff we are doing right now: this is the \u201cmain\u201d milestone. We give it a name (like Alpha 2 or Strawberry Rhubarb Pie) and we write down what we are trying to accomplish with the milestone. We create a new milestone when we are ready for the next iteration. Stuff we\u2019ll probably do soon: this is a standing \u201c**Next Tasks**\u201d milestone. We never change or rename this milestone. We use a permanent \u201cNext Tasks\u201d milestone (as opposed to renaming it to \u201cAlpha 3\u201d or actual-next-iteration milestone) because we don\u2019t want to presume or default to including something in the real next iteration. When we\u2019re ready to start planning the next iteration we\u2019ll create a new milestone, and only deliberately move things into that milestone. Stuff we probably won\u2019t do soon: this is a standing \u201c**Blue Sky**\u201d milestone. We refer to these tickets and sometimes look through them, but they are easy to ignore, somewhat intentionally ignored. What aren\u2019t we sure about?: issues with no milestone. Label: \u201cNeeds Discussion\u201d - (addressed in a triage meeting) - use liberally for either big or small tickets \u201cIt\u2019s better to give people more power: it\u2019s actually helpful if people can overreach because it is an opportunity to establish where the limits really are and what purpose those limits have\u201d External Links \u2693\ufe0e TODO: Revisit Git: The Simple Guide Commit Messages and why use the present tense Github\u2019s Advice on Github Most Comprehensive Guide Git Pro Book (free) Bash Tab-Completion Snippet Python \u2693\ufe0e TODO: Revisit Python Style Guides https://gist.github.com/sloria/7001839 http://www.nilunder.com/blog/2013/08/03/pythonic-sensibilities/ https://innoq.github.io/cards42org_en/ https://docs.openstack.org/hacking/latest/user/hacking.html#styleguide https://www.python.org/doc/humor/ https://docs.python-guide.org/writing/reading/ https://realpython.com/python-refactoring/ ADRs \u2693\ufe0e TODO: Revisit Examples https://github.com/pawamoy/mkdocstrings/issues/28 <\u2013 Links \u2013>","title":"Personal Style Guides"},{"location":"docs/STYLE_GUIDE/#personal-style-guides","text":"","title":"Personal Style Guides"},{"location":"docs/STYLE_GUIDE/#git","text":"We use Commitizen to manage both an auto-generated Changelog and incrementing the release version following semver . For both of these automated outputs to work well, please follow the Conventional Commits style, which is described in more detail below.","title":"Git"},{"location":"docs/STYLE_GUIDE/#commitizen-types-and-scopes","text":"type(scope): description Types fix : A bug fix feat : A new feature docs : Documentation-only changes (code comments, separate docs) style : Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons) perf : A code change that improves performance refactor : A change to production code that is not a fix , feat , or perf test : Adding missing or correcting existing tests build : Changes that affect the build system or external dependencies ci : Changes to our CI configuration files and scripts A ! can be used to indicate a breaking change ( refactor!: drop support for Node 6 ) SemVer Rules Based on commit type, the version will be auto-incremented: fix : PATCH // feat : MINOR // BREAKING CHANGE : MAJOR Scopes A Class, File name, Issue Number, other appropriate noun. As examples: build(poetry): bump requests to v3 or style(#32): add missing type annotations Tips What if a commit fits multiple types? Go back and make multiple commits whenever possible. Part of the benefit of Conventional Commits is the focus on more organized and intentional changes Use git rebase -i to fix commit names prior to merging if incorrect types/scopes are used","title":"Commitizen Types and Scopes"},{"location":"docs/STYLE_GUIDE/#git-description-guidelines","text":"Commit message guidelines Full sentence with verb ( lowercase ) and concise description. Below are modified examples for Conventional Commits fix(roles): bug in admin role permissions feat(ui): implement new button design build(pip): upgrade package to remove vulnerabilities refactor: file structure to improve code readability perf(cli): rewrite methods feat(api): endpoints to implement new customer dashboard How to write a good commit message A diff will tell you what changed, but only the commit message can properly tell you why. Keep in mind: This has all been said before . From the seven rules of a great Git commit message: Try for 50 characters, but consider 72 the hard limit Use the body to explain what and why vs. how","title":"Git Description Guidelines"},{"location":"docs/STYLE_GUIDE/#issue-labels-and-milestones","text":"Personal Guide For Issue Labels, see labels.yml Milestones Current Tasks : main milestone ( name could change based on a specific project, sprint, or month ) Next Tasks Blue Sky Research [Sane Github Labels](https://medium.com/@dave_lunny/sane-github-labels-c5d2e6004b63) and see [sensible-github-labels](https://github.com/Relequestual/sensible-github-labels) for full descriptions of each \u201cit is much more helpful to see the status and type of all issues at a glance.\u201d One of each: Status: \u2026 Abandoned, Accepted, Available, Blocked, Completed, In Progress, On Hold, Pending, Review Needed, Revision Needed Type: \u2026 Bug, Maintenance, Question, Enhancement Priority: \u2026 Critical, High, Medium, Low [Britecharts](https://britecharts.github.io/britecharts/github-labels.html) Status: \u2026 On Review \u2013 Request that we are pondering if including or not Needs Reproducing \u2013 For bugs that need to be reproduced in order to get fixed Needs Design \u2013 Feature that needs a design Ready to Go \u2013 Issue that has been defined and is ready to get started with In Progress \u2013 Issue that is being worked on right now. Completed \u2013 Finished feature or fix Type: \u2026 Bug \u2013 An unexpected problem or unintended behavior Feature \u2013 A new feature request Maintenance \u2013 A regular maintenance chore or task, including refactors, build system, CI, performance improvements Documentation \u2013 A documentation improvement task Question \u2013 An issue or PR that needs more information or a user question Not Included Priority: They would add complexity and overhead due to the discussions, but could help with the roadmap Technology Labels: It can create too much overhead, as properly tag with technologies all the issues could be time consuming [Ian Bicking Blog](https://www.ianbicking.org/blog/2014/03/use-github-issues-to-organize-a-project.html) Milestone Overview What are we doing right now? What aren\u2019t we doing right now? 2a. Stuff we\u2019ll probably do soon 2b. Stuff we probably won\u2019t do soon What aren\u2019t we sure about? Milestone Descriptions Stuff we are doing right now: this is the \u201cmain\u201d milestone. We give it a name (like Alpha 2 or Strawberry Rhubarb Pie) and we write down what we are trying to accomplish with the milestone. We create a new milestone when we are ready for the next iteration. Stuff we\u2019ll probably do soon: this is a standing \u201c**Next Tasks**\u201d milestone. We never change or rename this milestone. We use a permanent \u201cNext Tasks\u201d milestone (as opposed to renaming it to \u201cAlpha 3\u201d or actual-next-iteration milestone) because we don\u2019t want to presume or default to including something in the real next iteration. When we\u2019re ready to start planning the next iteration we\u2019ll create a new milestone, and only deliberately move things into that milestone. Stuff we probably won\u2019t do soon: this is a standing \u201c**Blue Sky**\u201d milestone. We refer to these tickets and sometimes look through them, but they are easy to ignore, somewhat intentionally ignored. What aren\u2019t we sure about?: issues with no milestone. Label: \u201cNeeds Discussion\u201d - (addressed in a triage meeting) - use liberally for either big or small tickets \u201cIt\u2019s better to give people more power: it\u2019s actually helpful if people can overreach because it is an opportunity to establish where the limits really are and what purpose those limits have\u201d","title":"Issue Labels and Milestones"},{"location":"docs/STYLE_GUIDE/#external-links","text":"TODO: Revisit Git: The Simple Guide Commit Messages and why use the present tense Github\u2019s Advice on Github Most Comprehensive Guide Git Pro Book (free) Bash Tab-Completion Snippet","title":"External Links"},{"location":"docs/STYLE_GUIDE/#python","text":"TODO: Revisit Python Style Guides https://gist.github.com/sloria/7001839 http://www.nilunder.com/blog/2013/08/03/pythonic-sensibilities/ https://innoq.github.io/cards42org_en/ https://docs.openstack.org/hacking/latest/user/hacking.html#styleguide https://www.python.org/doc/humor/ https://docs.python-guide.org/writing/reading/ https://realpython.com/python-refactoring/","title":"Python"},{"location":"docs/STYLE_GUIDE/#adrs","text":"TODO: Revisit Examples https://github.com/pawamoy/mkdocstrings/issues/28 <\u2013 Links \u2013>","title":"ADRs"},{"location":"modules/pytest_cache_assert/_code_diagrams/","text":"Code Diagrams \u2693\ufe0e Auto-generated with pylint-pyreverse Packages \u2693\ufe0e Full Size Classes \u2693\ufe0e Full Size","title":"Pytest cache assert"},{"location":"modules/pytest_cache_assert/_code_diagrams/#code-diagrams","text":"Auto-generated with pylint-pyreverse","title":"Code Diagrams"},{"location":"modules/pytest_cache_assert/_code_diagrams/#packages","text":"Full Size","title":"Packages"},{"location":"modules/pytest_cache_assert/_code_diagrams/#classes","text":"Full Size","title":"Classes"},{"location":"reference/SUMMARY/","text":"pytest_cache_assert * _check_assert * assert_config * assert_rules * cache_store * caching * config * constants * converter * differ * error_message * serializer * validator * main * plugin","title":"SUMMARY"},{"location":"reference/pytest_cache_assert/","text":"pytest_cache_assert. Attributes \u2693\ufe0e Classes \u2693\ufe0e Functions \u2693\ufe0e","title":"pytest_cache_assert"},{"location":"reference/pytest_cache_assert/#pytest_cache_assert-attributes","text":"","title":"Attributes"},{"location":"reference/pytest_cache_assert/#pytest_cache_assert-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/#pytest_cache_assert-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/main/","text":"Assertion checks for unit tests. FYI: Should not require any pytest functionality Functions \u2693\ufe0e assert_against_cache \u2693\ufe0e assert_against_cache ( test_data , * , path_cache_dir , cache_name , assert_rules = None , metadata = None , always_write = None ) Core logic for pytest_cache_assert to handle caching and assertion-checking. PARAMETER DESCRIPTION test_data dictionary or list to test (could be from cache) TYPE: Any path_cache_dir location of the cache directory TYPE: Path cache_name relative string path from the test_dir to the JSON cache file TYPE: str assert_rules dictionary of AssertRules to apply when selectively ignoring differences TYPE: Optional [ List [ AssertRule ]] DEFAULT: None metadata metadata dictionary to store in the cache file TYPE: Optional [ Dict ] DEFAULT: None always_write if True, always write the changes TYPE: Optional [ bool ] DEFAULT: None Source code in pytest_cache_assert/main.py @beartype def assert_against_cache ( test_data : Any , * , path_cache_dir : Path , cache_name : str , assert_rules : Optional [ List [ AssertRule ]] = None , metadata : Optional [ Dict ] = None , # type: ignore[type-arg] always_write : Optional [ bool ] = None , ) -> None : \"\"\"Core logic for pytest_cache_assert to handle caching and assertion-checking. Args: test_data: dictionary or list to test (could be from cache) path_cache_dir: location of the cache directory cache_name: relative string path from the test_dir to the JSON cache file assert_rules: dictionary of AssertRules to apply when selectively ignoring differences metadata: metadata dictionary to store in the cache file always_write: if True, always write the changes \"\"\" config = retrieve ( CacheAssertContainerKeys . CONFIG ) cache_store = config . cache_store path_cache_file = path_cache_dir / cache_name cache_store . initialize ( path_cache_dir , config . converters ) test_data = cache_store . serialize ( test_data ) # Function argument overrides global aw = config . always_write if always_write is None else always_write try : cached_data = cache_store . read_cached_data ( path_cache_file ) except NoCacheError : cached_data = test_data cache_store . write ( path_cache_file , metadata = metadata , test_data = test_data , always_write = aw ) validator = config . validator validator . assertion ( cached_data = cached_data , test_data = test_data , assert_rules = assert_rules or [], path_cache_file = path_cache_file , ) assert_against_dict \u2693\ufe0e assert_against_dict ( old_dict , new_dict , assert_rules = None ) Utilize custom DictDiffer logic to compare in-memory dictionaries. PARAMETER DESCRIPTION old_dict old dictionary (typically cached one) TYPE: Dict new_dict new dictionary (typically test data) TYPE: Dict assert_rules dictionary of AssertRules to apply when selectively ignoring differences TYPE: Optional [ List [ AssertRule ]] DEFAULT: None Source code in pytest_cache_assert/main.py @beartype def assert_against_dict ( old_dict : Dict , # type: ignore[type-arg] new_dict : Dict , # type: ignore[type-arg] assert_rules : Optional [ List [ AssertRule ]] = None , ) -> None : \"\"\"Utilize custom DictDiffer logic to compare in-memory dictionaries. Args: old_dict: old dictionary (typically cached one) new_dict: new dictionary (typically test data) assert_rules: dictionary of AssertRules to apply when selectively ignoring differences \"\"\" config = retrieve ( CacheAssertContainerKeys . CONFIG ) cache_store = config . cache_store cache_store . initialize ( None , config . converters ) new_dict = cache_store . serialize ( new_dict ) validator = config . validator validator . assertion ( cached_data = old_dict , test_data = new_dict , assert_rules = assert_rules or [])","title":"main"},{"location":"reference/pytest_cache_assert/main/#pytest_cache_assert.main-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/main/#pytest_cache_assert.main.assert_against_cache","text":"assert_against_cache ( test_data , * , path_cache_dir , cache_name , assert_rules = None , metadata = None , always_write = None ) Core logic for pytest_cache_assert to handle caching and assertion-checking. PARAMETER DESCRIPTION test_data dictionary or list to test (could be from cache) TYPE: Any path_cache_dir location of the cache directory TYPE: Path cache_name relative string path from the test_dir to the JSON cache file TYPE: str assert_rules dictionary of AssertRules to apply when selectively ignoring differences TYPE: Optional [ List [ AssertRule ]] DEFAULT: None metadata metadata dictionary to store in the cache file TYPE: Optional [ Dict ] DEFAULT: None always_write if True, always write the changes TYPE: Optional [ bool ] DEFAULT: None Source code in pytest_cache_assert/main.py @beartype def assert_against_cache ( test_data : Any , * , path_cache_dir : Path , cache_name : str , assert_rules : Optional [ List [ AssertRule ]] = None , metadata : Optional [ Dict ] = None , # type: ignore[type-arg] always_write : Optional [ bool ] = None , ) -> None : \"\"\"Core logic for pytest_cache_assert to handle caching and assertion-checking. Args: test_data: dictionary or list to test (could be from cache) path_cache_dir: location of the cache directory cache_name: relative string path from the test_dir to the JSON cache file assert_rules: dictionary of AssertRules to apply when selectively ignoring differences metadata: metadata dictionary to store in the cache file always_write: if True, always write the changes \"\"\" config = retrieve ( CacheAssertContainerKeys . CONFIG ) cache_store = config . cache_store path_cache_file = path_cache_dir / cache_name cache_store . initialize ( path_cache_dir , config . converters ) test_data = cache_store . serialize ( test_data ) # Function argument overrides global aw = config . always_write if always_write is None else always_write try : cached_data = cache_store . read_cached_data ( path_cache_file ) except NoCacheError : cached_data = test_data cache_store . write ( path_cache_file , metadata = metadata , test_data = test_data , always_write = aw ) validator = config . validator validator . assertion ( cached_data = cached_data , test_data = test_data , assert_rules = assert_rules or [], path_cache_file = path_cache_file , )","title":"assert_against_cache()"},{"location":"reference/pytest_cache_assert/main/#pytest_cache_assert.main.assert_against_dict","text":"assert_against_dict ( old_dict , new_dict , assert_rules = None ) Utilize custom DictDiffer logic to compare in-memory dictionaries. PARAMETER DESCRIPTION old_dict old dictionary (typically cached one) TYPE: Dict new_dict new dictionary (typically test data) TYPE: Dict assert_rules dictionary of AssertRules to apply when selectively ignoring differences TYPE: Optional [ List [ AssertRule ]] DEFAULT: None Source code in pytest_cache_assert/main.py @beartype def assert_against_dict ( old_dict : Dict , # type: ignore[type-arg] new_dict : Dict , # type: ignore[type-arg] assert_rules : Optional [ List [ AssertRule ]] = None , ) -> None : \"\"\"Utilize custom DictDiffer logic to compare in-memory dictionaries. Args: old_dict: old dictionary (typically cached one) new_dict: new dictionary (typically test data) assert_rules: dictionary of AssertRules to apply when selectively ignoring differences \"\"\" config = retrieve ( CacheAssertContainerKeys . CONFIG ) cache_store = config . cache_store cache_store . initialize ( None , config . converters ) new_dict = cache_store . serialize ( new_dict ) validator = config . validator validator . assertion ( cached_data = old_dict , test_data = new_dict , assert_rules = assert_rules or [])","title":"assert_against_dict()"},{"location":"reference/pytest_cache_assert/plugin/","text":"Pytest Plugin. Classes \u2693\ufe0e TestMetadata \u2693\ufe0e Bases: BaseModel Test MetaData. Source code in pytest_cache_assert/plugin.py class TestMetadata ( BaseModel ): \"\"\"Test MetaData.\"\"\" test_file : str test_name : str func_args : Union [ Dict , Iterable ] # type: ignore[type-arg] class Config : arbitrary_types_allowed = True frozen = True @classmethod @beartype def from_pytest ( cls , request : FixtureRequest , rel_test_file : Path ) -> TestMetadata : \"\"\"Resolve TestMetadata. Args: request: pytest fixture used to identify the test directory rel_test_file: relative path to the test file Returns: TestMetadata: new TestMetadata \"\"\" test_name = ( f ' { request . cls . __name__ } /' if request . cls else '' ) + request . node . originalname test_params = [ * inspect . signature ( request . node . function ) . parameters . keys ()] func_args = { key : value for key , value in request . node . funcargs . items () if key in test_params } return cls ( test_file = rel_test_file . as_posix (), test_name = test_name , func_args = func_args ) Functions \u2693\ufe0e from_pytest classmethod \u2693\ufe0e from_pytest ( request , rel_test_file ) Resolve TestMetadata. PARAMETER DESCRIPTION request pytest fixture used to identify the test directory TYPE: FixtureRequest rel_test_file relative path to the test file TYPE: Path RETURNS DESCRIPTION TestMetadata new TestMetadata TYPE: TestMetadata Source code in pytest_cache_assert/plugin.py @classmethod @beartype def from_pytest ( cls , request : FixtureRequest , rel_test_file : Path ) -> TestMetadata : \"\"\"Resolve TestMetadata. Args: request: pytest fixture used to identify the test directory rel_test_file: relative path to the test file Returns: TestMetadata: new TestMetadata \"\"\" test_name = ( f ' { request . cls . __name__ } /' if request . cls else '' ) + request . node . originalname test_params = [ * inspect . signature ( request . node . function ) . parameters . keys ()] func_args = { key : value for key , value in request . node . funcargs . items () if key in test_params } return cls ( test_file = rel_test_file . as_posix (), test_name = test_name , func_args = func_args ) Functions \u2693\ufe0e assert_against_cache \u2693\ufe0e assert_against_cache ( request , cache_assert_config = None ) Return main.assert_against_cache with pytest-specific arguments already specified. PARAMETER DESCRIPTION request pytest fixture used to identify the test directory TYPE: FixtureRequest cache_assert_config pytest fixture that returns AssertConfig for user configuration TYPE: Optional [ AssertConfig ] DEFAULT: None RETURNS DESCRIPTION Callable [[ Any ], None] Callable[[Any], None]: main.assert_against_cache() with test_dir already specified RAISES DESCRIPTION RuntimeError if the test directory cannot be determined Source code in pytest_cache_assert/plugin.py @pytest . fixture () @beartype def assert_against_cache ( request : FixtureRequest , cache_assert_config : Optional [ AssertConfig ] = None , ) -> Callable [[ Any ], None ]: \"\"\"Return main.assert_against_cache with pytest-specific arguments already specified. Args: request: pytest fixture used to identify the test directory cache_assert_config: pytest fixture that returns AssertConfig for user configuration Returns: Callable[[Any], None]: `main.assert_against_cache()` with test_dir already specified Raises: RuntimeError: if the test directory cannot be determined \"\"\" if cache_assert_config : register ( CacheAssertContainerKeys . CONFIG , cache_assert_config ) assert_config = retrieve ( CacheAssertContainerKeys . CONFIG ) test_dir = None for sub_dir in [ 'tests' , 'test' ]: test_dir = request . config . rootpath / sub_dir if test_dir . is_dir (): break else : raise RuntimeError ( f 'Could not locate a \"tests/\" directory in { test_dir } ' ) # Read user settings path_cache_dir = test_dir / assert_config . cache_dir_rel_path # Calculate keyword arguments rel_test_file = Path ( request . node . fspath ) . relative_to ( test_dir ) # Escape slashes from the pytest node name test_name = _RE_UNSAFE_CHAR . sub ( '-' , request . node . name ) cache_name = ( rel_test_file . parent / rel_test_file . stem / f ' { test_name } .json' ) . as_posix () # noqa: ECE001 metadata = TestMetadata . from_pytest ( request = request , rel_test_file = rel_test_file ) . dict () # FYI: The partial function keyword arguments can be overridden when called return partial ( main . assert_against_cache , path_cache_dir = path_cache_dir , cache_name = cache_name , metadata = metadata )","title":"plugin"},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin.TestMetadata","text":"Bases: BaseModel Test MetaData. Source code in pytest_cache_assert/plugin.py class TestMetadata ( BaseModel ): \"\"\"Test MetaData.\"\"\" test_file : str test_name : str func_args : Union [ Dict , Iterable ] # type: ignore[type-arg] class Config : arbitrary_types_allowed = True frozen = True @classmethod @beartype def from_pytest ( cls , request : FixtureRequest , rel_test_file : Path ) -> TestMetadata : \"\"\"Resolve TestMetadata. Args: request: pytest fixture used to identify the test directory rel_test_file: relative path to the test file Returns: TestMetadata: new TestMetadata \"\"\" test_name = ( f ' { request . cls . __name__ } /' if request . cls else '' ) + request . node . originalname test_params = [ * inspect . signature ( request . node . function ) . parameters . keys ()] func_args = { key : value for key , value in request . node . funcargs . items () if key in test_params } return cls ( test_file = rel_test_file . as_posix (), test_name = test_name , func_args = func_args )","title":"TestMetadata"},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin.TestMetadata-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin.TestMetadata.from_pytest","text":"from_pytest ( request , rel_test_file ) Resolve TestMetadata. PARAMETER DESCRIPTION request pytest fixture used to identify the test directory TYPE: FixtureRequest rel_test_file relative path to the test file TYPE: Path RETURNS DESCRIPTION TestMetadata new TestMetadata TYPE: TestMetadata Source code in pytest_cache_assert/plugin.py @classmethod @beartype def from_pytest ( cls , request : FixtureRequest , rel_test_file : Path ) -> TestMetadata : \"\"\"Resolve TestMetadata. Args: request: pytest fixture used to identify the test directory rel_test_file: relative path to the test file Returns: TestMetadata: new TestMetadata \"\"\" test_name = ( f ' { request . cls . __name__ } /' if request . cls else '' ) + request . node . originalname test_params = [ * inspect . signature ( request . node . function ) . parameters . keys ()] func_args = { key : value for key , value in request . node . funcargs . items () if key in test_params } return cls ( test_file = rel_test_file . as_posix (), test_name = test_name , func_args = func_args )","title":"from_pytest()"},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin.assert_against_cache","text":"assert_against_cache ( request , cache_assert_config = None ) Return main.assert_against_cache with pytest-specific arguments already specified. PARAMETER DESCRIPTION request pytest fixture used to identify the test directory TYPE: FixtureRequest cache_assert_config pytest fixture that returns AssertConfig for user configuration TYPE: Optional [ AssertConfig ] DEFAULT: None RETURNS DESCRIPTION Callable [[ Any ], None] Callable[[Any], None]: main.assert_against_cache() with test_dir already specified RAISES DESCRIPTION RuntimeError if the test directory cannot be determined Source code in pytest_cache_assert/plugin.py @pytest . fixture () @beartype def assert_against_cache ( request : FixtureRequest , cache_assert_config : Optional [ AssertConfig ] = None , ) -> Callable [[ Any ], None ]: \"\"\"Return main.assert_against_cache with pytest-specific arguments already specified. Args: request: pytest fixture used to identify the test directory cache_assert_config: pytest fixture that returns AssertConfig for user configuration Returns: Callable[[Any], None]: `main.assert_against_cache()` with test_dir already specified Raises: RuntimeError: if the test directory cannot be determined \"\"\" if cache_assert_config : register ( CacheAssertContainerKeys . CONFIG , cache_assert_config ) assert_config = retrieve ( CacheAssertContainerKeys . CONFIG ) test_dir = None for sub_dir in [ 'tests' , 'test' ]: test_dir = request . config . rootpath / sub_dir if test_dir . is_dir (): break else : raise RuntimeError ( f 'Could not locate a \"tests/\" directory in { test_dir } ' ) # Read user settings path_cache_dir = test_dir / assert_config . cache_dir_rel_path # Calculate keyword arguments rel_test_file = Path ( request . node . fspath ) . relative_to ( test_dir ) # Escape slashes from the pytest node name test_name = _RE_UNSAFE_CHAR . sub ( '-' , request . node . name ) cache_name = ( rel_test_file . parent / rel_test_file . stem / f ' { test_name } .json' ) . as_posix () # noqa: ECE001 metadata = TestMetadata . from_pytest ( request = request , rel_test_file = rel_test_file ) . dict () # FYI: The partial function keyword arguments can be overridden when called return partial ( main . assert_against_cache , path_cache_dir = path_cache_dir , cache_name = cache_name , metadata = metadata )","title":"assert_against_cache()"},{"location":"reference/pytest_cache_assert/_check_assert/","text":"Private package for pytest_check_assert.","title":"_check_assert"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/","text":"Pytest Cache Assert Configuration Object. Attributes \u2693\ufe0e Classes \u2693\ufe0e AssertConfig \u2693\ufe0e Bases: BaseModel User configuration data structure. Source code in pytest_cache_assert/_check_assert/assert_config.py class AssertConfig ( BaseModel ): \"\"\"User configuration data structure.\"\"\" always_write : bool = False \"\"\"Always write to the cached file so that diffs can be examined in the user's VCS.\"\"\" cache_dir_rel_path : str = DEF_CACHE_DIR_NAME \"\"\"String relative directory from `tests/`. Default resolves to `tests/assert-cache/`.\"\"\" cache_store : CacheStoreType = Field ( default_factory = LocalJSONCacheStore ) \"\"\"Configurable class for managing the cache representation. Default is local JSON. Override the default `cache_store` to have a custom cache format and serialization \"\"\" converters : List [ Converter ] = Field ( default_factory = list ) \"\"\"Extend cache_store with custom functions for serializing novel types. Example: `[Converter(types=[pd.DataFrame], func=panda_to_json)]` for ```py def panda_to_json(df: pd.DataFrame) -> List[Dict]: return json.loads(df.to_json(orient='records')) ``` Useful for serializing data form pandas or other types that are unknown to the generic converters \"\"\" validator : ValidatorType = Field ( default_factory = DictDiffValidator ) \"\"\"Custom validator for identifying and summarizing the deviations from the cache.\"\"\" class Config : arbitrary_types_allowed = True Attributes \u2693\ufe0e always_write class-attribute \u2693\ufe0e always_write : bool = False Always write to the cached file so that diffs can be examined in the user\u2019s VCS. cache_dir_rel_path class-attribute \u2693\ufe0e cache_dir_rel_path : str = DEF_CACHE_DIR_NAME String relative directory from tests/ . Default resolves to tests/assert-cache/ . cache_store class-attribute \u2693\ufe0e cache_store : CacheStoreType = Field ( default_factory = LocalJSONCacheStore ) Configurable class for managing the cache representation. Default is local JSON. Override the default cache_store to have a custom cache format and serialization converters class-attribute \u2693\ufe0e converters : List [ Converter ] = Field ( default_factory = list ) Extend cache_store with custom functions for serializing novel types. Example: [Converter(types=[pd.DataFrame], func=panda_to_json)] for def panda_to_json ( df : pd . DataFrame ) -> List [ Dict ]: return json . loads ( df . to_json ( orient = 'records' )) Useful for serializing data form pandas or other types that are unknown to the generic converters validator class-attribute \u2693\ufe0e validator : ValidatorType = Field ( default_factory = DictDiffValidator ) Custom validator for identifying and summarizing the deviations from the cache.","title":"assert_config"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config-attributes","text":"","title":"Attributes"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig","text":"Bases: BaseModel User configuration data structure. Source code in pytest_cache_assert/_check_assert/assert_config.py class AssertConfig ( BaseModel ): \"\"\"User configuration data structure.\"\"\" always_write : bool = False \"\"\"Always write to the cached file so that diffs can be examined in the user's VCS.\"\"\" cache_dir_rel_path : str = DEF_CACHE_DIR_NAME \"\"\"String relative directory from `tests/`. Default resolves to `tests/assert-cache/`.\"\"\" cache_store : CacheStoreType = Field ( default_factory = LocalJSONCacheStore ) \"\"\"Configurable class for managing the cache representation. Default is local JSON. Override the default `cache_store` to have a custom cache format and serialization \"\"\" converters : List [ Converter ] = Field ( default_factory = list ) \"\"\"Extend cache_store with custom functions for serializing novel types. Example: `[Converter(types=[pd.DataFrame], func=panda_to_json)]` for ```py def panda_to_json(df: pd.DataFrame) -> List[Dict]: return json.loads(df.to_json(orient='records')) ``` Useful for serializing data form pandas or other types that are unknown to the generic converters \"\"\" validator : ValidatorType = Field ( default_factory = DictDiffValidator ) \"\"\"Custom validator for identifying and summarizing the deviations from the cache.\"\"\" class Config : arbitrary_types_allowed = True","title":"AssertConfig"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig-attributes","text":"","title":"Attributes"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig.always_write","text":"always_write : bool = False Always write to the cached file so that diffs can be examined in the user\u2019s VCS.","title":"always_write"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig.cache_dir_rel_path","text":"cache_dir_rel_path : str = DEF_CACHE_DIR_NAME String relative directory from tests/ . Default resolves to tests/assert-cache/ .","title":"cache_dir_rel_path"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig.cache_store","text":"cache_store : CacheStoreType = Field ( default_factory = LocalJSONCacheStore ) Configurable class for managing the cache representation. Default is local JSON. Override the default cache_store to have a custom cache format and serialization","title":"cache_store"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig.converters","text":"converters : List [ Converter ] = Field ( default_factory = list ) Extend cache_store with custom functions for serializing novel types. Example: [Converter(types=[pd.DataFrame], func=panda_to_json)] for def panda_to_json ( df : pd . DataFrame ) -> List [ Dict ]: return json . loads ( df . to_json ( orient = 'records' )) Useful for serializing data form pandas or other types that are unknown to the generic converters","title":"converters"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig.validator","text":"validator : ValidatorType = Field ( default_factory = DictDiffValidator ) Custom validator for identifying and summarizing the deviations from the cache.","title":"validator"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/","text":"Key Rules. Attributes \u2693\ufe0e Classes \u2693\ufe0e AssertRule \u2693\ufe0e Bases: BaseModel Key Rule. Source code in pytest_cache_assert/_check_assert/assert_rules.py class AssertRule ( BaseModel ): \"\"\"Key Rule.\"\"\" pattern : Union [ str , Pattern ] # type: ignore[type-arg] # https://github.com/pydantic/pydantic/issues/2636 func : Callable [[ T_DIFF , T_DIFF ], bool ] @classmethod def build_re ( cls , pattern : List [ Union [ str , Wild ]], func : Callable [[ T_DIFF , T_DIFF ], bool ]) -> 'AssertRule' : \"\"\"Build a regex pattern from list.\"\"\" if not pattern : raise ValueError ( \"Expected at least one item in 'pattern'\" ) if pattern [ 0 ] . startswith ( 'root[' ): raise ValueError ( \"Exclude 'root' and brackets. This method builds it for you\" ) pattern_re = f 'root { _PAT_START }{ _PAT_JOIN . join ( pattern ) }{ _PAT_END } ' return cls ( pattern = re . compile ( pattern_re ), func = func ) def is_regex ( self ) -> bool : \"\"\"Helper for checking if pattern is a regex or string.\"\"\" return not isinstance ( self . pattern , str ) Functions \u2693\ufe0e build_re classmethod \u2693\ufe0e build_re ( pattern , func ) Build a regex pattern from list. Source code in pytest_cache_assert/_check_assert/assert_rules.py @classmethod def build_re ( cls , pattern : List [ Union [ str , Wild ]], func : Callable [[ T_DIFF , T_DIFF ], bool ]) -> 'AssertRule' : \"\"\"Build a regex pattern from list.\"\"\" if not pattern : raise ValueError ( \"Expected at least one item in 'pattern'\" ) if pattern [ 0 ] . startswith ( 'root[' ): raise ValueError ( \"Exclude 'root' and brackets. This method builds it for you\" ) pattern_re = f 'root { _PAT_START }{ _PAT_JOIN . join ( pattern ) }{ _PAT_END } ' return cls ( pattern = re . compile ( pattern_re ), func = func ) is_regex \u2693\ufe0e is_regex () Helper for checking if pattern is a regex or string. Source code in pytest_cache_assert/_check_assert/assert_rules.py def is_regex ( self ) -> bool : \"\"\"Helper for checking if pattern is a regex or string.\"\"\" return not isinstance ( self . pattern , str ) Comparator \u2693\ufe0e Bases: Enum Comparator Enum for AssertRules. Source code in pytest_cache_assert/_check_assert/assert_rules.py class Comparator ( Enum ): # noqa: H601 \"\"\"Comparator Enum for AssertRules.\"\"\" LTE = 'new - old <= value' GTE = 'new - old >= value' WITHIN = 'abs(new - old) <= value' Wild \u2693\ufe0e Bases: StrEnum AssertRule Wildcard Patterns. Source code in pytest_cache_assert/_check_assert/assert_rules.py class Wild ( StrEnum ): # type: ignore[misc] \"\"\"AssertRule Wildcard Patterns.\"\"\" @classmethod def build ( cls , inner_pattern : str , count : int = 1 ) -> str : \"\"\"Specify a custom regular expression to match nested keys.\"\"\" if count < 1 : raise ValueError ( 'Count must be at least one' ) return _PAT_JOIN . join ([ inner_pattern ] * count ) @classmethod def index ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches a specific number of nested lists in the cached data.\"\"\" return cls . build ( r '\\d+' , count ) @classmethod def keys ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches a specific number of nested dictionary keys.\"\"\" return cls . build ( r '[^\\]]+' , count ) @classmethod def recur ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches any level of nested dictionary keys or lists indices.\"\"\" return cls . build ( r '.+' , count ) Functions \u2693\ufe0e build classmethod \u2693\ufe0e build ( inner_pattern , count = 1 ) Specify a custom regular expression to match nested keys. Source code in pytest_cache_assert/_check_assert/assert_rules.py @classmethod def build ( cls , inner_pattern : str , count : int = 1 ) -> str : \"\"\"Specify a custom regular expression to match nested keys.\"\"\" if count < 1 : raise ValueError ( 'Count must be at least one' ) return _PAT_JOIN . join ([ inner_pattern ] * count ) index classmethod \u2693\ufe0e index ( count = 1 ) Return pattern that matches a specific number of nested lists in the cached data. Source code in pytest_cache_assert/_check_assert/assert_rules.py @classmethod def index ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches a specific number of nested lists in the cached data.\"\"\" return cls . build ( r '\\d+' , count ) keys classmethod \u2693\ufe0e keys ( count = 1 ) Return pattern that matches a specific number of nested dictionary keys. Source code in pytest_cache_assert/_check_assert/assert_rules.py @classmethod def keys ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches a specific number of nested dictionary keys.\"\"\" return cls . build ( r '[^\\]]+' , count ) recur classmethod \u2693\ufe0e recur ( count = 1 ) Return pattern that matches any level of nested dictionary keys or lists indices. Source code in pytest_cache_assert/_check_assert/assert_rules.py @classmethod def recur ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches any level of nested dictionary keys or lists indices.\"\"\" return cls . build ( r '.+' , count ) Functions \u2693\ufe0e check_exact \u2693\ufe0e check_exact ( old , new ) Check for value equality. PARAMETER DESCRIPTION old the old value TYPE: T_DIFF new the new value TYPE: T_DIFF RETURNS DESCRIPTION bool True if both values are the exact same TYPE: bool Source code in pytest_cache_assert/_check_assert/assert_rules.py @beartype def check_exact ( old : T_DIFF , new : T_DIFF ) -> bool : \"\"\"Check for value equality. Args: old: the old value new: the new value Returns: bool: True if both values are the exact same \"\"\" return old == new # type: ignore[no-any-return] check_suppress \u2693\ufe0e check_suppress ( old , new ) Return True to suppress differences. PARAMETER DESCRIPTION old the old value TYPE: T_DIFF new the new value TYPE: T_DIFF RETURNS DESCRIPTION bool Always True TYPE: bool Source code in pytest_cache_assert/_check_assert/assert_rules.py @beartype def check_suppress ( old : T_DIFF , new : T_DIFF ) -> bool : \"\"\"Return True to suppress differences. Args: old: the old value new: the new value Returns: bool: Always True \"\"\" return True check_type \u2693\ufe0e check_type ( old , new ) Check if both values are the exact same or same non-string type. Will attempt conversion from string. PARAMETER DESCRIPTION old the old value TYPE: T_DIFF new the new value TYPE: T_DIFF RETURNS DESCRIPTION bool True if both values are the same kind TYPE: bool Source code in pytest_cache_assert/_check_assert/assert_rules.py @beartype def check_type ( old : T_DIFF , new : T_DIFF ) -> bool : \"\"\"Check if both values are the exact same or same non-string type. Will attempt conversion from string. Args: old: the old value new: the new value Returns: bool: True if both values are the same kind \"\"\" if ( check_exact ( old = old , new = new ) # Catches if both null, etc. or ( not isinstance ( old , str ) and isinstance ( old , type ( new ))) ): return True return _try_type_coercion ( old = old , new = new ) gen_check_date_proximity \u2693\ufe0e gen_check_date_proximity ( time_delta , comparator = Comparator . WITHIN ) Generate a AssertRule check for date within the specified range. PARAMETER DESCRIPTION time_delta timedelta to use for checking that the new data is TYPE: timedelta comparator defaults to Comparator.WITHIN. Can make directional by setting LTE or GTE TYPE: Comparator DEFAULT: Comparator.WITHIN RETURNS DESCRIPTION Callable [[ T_DIFF , T_DIFF ], bool ] Callable[[T_DIFF, T_DIFF], bool]: AssertRule check Source code in pytest_cache_assert/_check_assert/assert_rules.py @beartype def gen_check_date_proximity ( time_delta : timedelta , comparator : Comparator = Comparator . WITHIN , ) -> Callable [[ T_DIFF , T_DIFF ], bool ]: \"\"\"Generate a AssertRule check for date within the specified range. Args: time_delta: timedelta to use for checking that the new data is comparator: defaults to Comparator.WITHIN. Can make directional by setting LTE or GTE Returns: Callable[[T_DIFF, T_DIFF], bool]: AssertRule check \"\"\" return partial ( _check_date_proximity , time_delta = time_delta , comparator = comparator ) gen_check_date_range \u2693\ufe0e gen_check_date_range ( min_date = None , max_date = None ) Generate a AssertRule check for date within the specified range. PARAMETER DESCRIPTION min_date optional minimum datetime TYPE: Optional [ datetime ] DEFAULT: None max_date optional maximum datetime TYPE: Optional [ datetime ] DEFAULT: None RETURNS DESCRIPTION Callable [[ T_DIFF , T_DIFF ], bool ] Callable[[T_DIFF, T_DIFF], bool]: AssertRule check Source code in pytest_cache_assert/_check_assert/assert_rules.py @beartype def gen_check_date_range ( min_date : Optional [ datetime ] = None , max_date : Optional [ datetime ] = None , ) -> Callable [[ T_DIFF , T_DIFF ], bool ]: \"\"\"Generate a AssertRule check for date within the specified range. Args: min_date: optional minimum datetime max_date: optional maximum datetime Returns: Callable[[T_DIFF, T_DIFF], bool]: AssertRule check \"\"\" return partial ( _check_date_range , min_date = min_date , max_date = max_date )","title":"assert_rules"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules-attributes","text":"","title":"Attributes"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.AssertRule","text":"Bases: BaseModel Key Rule. Source code in pytest_cache_assert/_check_assert/assert_rules.py class AssertRule ( BaseModel ): \"\"\"Key Rule.\"\"\" pattern : Union [ str , Pattern ] # type: ignore[type-arg] # https://github.com/pydantic/pydantic/issues/2636 func : Callable [[ T_DIFF , T_DIFF ], bool ] @classmethod def build_re ( cls , pattern : List [ Union [ str , Wild ]], func : Callable [[ T_DIFF , T_DIFF ], bool ]) -> 'AssertRule' : \"\"\"Build a regex pattern from list.\"\"\" if not pattern : raise ValueError ( \"Expected at least one item in 'pattern'\" ) if pattern [ 0 ] . startswith ( 'root[' ): raise ValueError ( \"Exclude 'root' and brackets. This method builds it for you\" ) pattern_re = f 'root { _PAT_START }{ _PAT_JOIN . join ( pattern ) }{ _PAT_END } ' return cls ( pattern = re . compile ( pattern_re ), func = func ) def is_regex ( self ) -> bool : \"\"\"Helper for checking if pattern is a regex or string.\"\"\" return not isinstance ( self . pattern , str )","title":"AssertRule"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.AssertRule-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.AssertRule.build_re","text":"build_re ( pattern , func ) Build a regex pattern from list. Source code in pytest_cache_assert/_check_assert/assert_rules.py @classmethod def build_re ( cls , pattern : List [ Union [ str , Wild ]], func : Callable [[ T_DIFF , T_DIFF ], bool ]) -> 'AssertRule' : \"\"\"Build a regex pattern from list.\"\"\" if not pattern : raise ValueError ( \"Expected at least one item in 'pattern'\" ) if pattern [ 0 ] . startswith ( 'root[' ): raise ValueError ( \"Exclude 'root' and brackets. This method builds it for you\" ) pattern_re = f 'root { _PAT_START }{ _PAT_JOIN . join ( pattern ) }{ _PAT_END } ' return cls ( pattern = re . compile ( pattern_re ), func = func )","title":"build_re()"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.AssertRule.is_regex","text":"is_regex () Helper for checking if pattern is a regex or string. Source code in pytest_cache_assert/_check_assert/assert_rules.py def is_regex ( self ) -> bool : \"\"\"Helper for checking if pattern is a regex or string.\"\"\" return not isinstance ( self . pattern , str )","title":"is_regex()"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Comparator","text":"Bases: Enum Comparator Enum for AssertRules. Source code in pytest_cache_assert/_check_assert/assert_rules.py class Comparator ( Enum ): # noqa: H601 \"\"\"Comparator Enum for AssertRules.\"\"\" LTE = 'new - old <= value' GTE = 'new - old >= value' WITHIN = 'abs(new - old) <= value'","title":"Comparator"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild","text":"Bases: StrEnum AssertRule Wildcard Patterns. Source code in pytest_cache_assert/_check_assert/assert_rules.py class Wild ( StrEnum ): # type: ignore[misc] \"\"\"AssertRule Wildcard Patterns.\"\"\" @classmethod def build ( cls , inner_pattern : str , count : int = 1 ) -> str : \"\"\"Specify a custom regular expression to match nested keys.\"\"\" if count < 1 : raise ValueError ( 'Count must be at least one' ) return _PAT_JOIN . join ([ inner_pattern ] * count ) @classmethod def index ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches a specific number of nested lists in the cached data.\"\"\" return cls . build ( r '\\d+' , count ) @classmethod def keys ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches a specific number of nested dictionary keys.\"\"\" return cls . build ( r '[^\\]]+' , count ) @classmethod def recur ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches any level of nested dictionary keys or lists indices.\"\"\" return cls . build ( r '.+' , count )","title":"Wild"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild.build","text":"build ( inner_pattern , count = 1 ) Specify a custom regular expression to match nested keys. Source code in pytest_cache_assert/_check_assert/assert_rules.py @classmethod def build ( cls , inner_pattern : str , count : int = 1 ) -> str : \"\"\"Specify a custom regular expression to match nested keys.\"\"\" if count < 1 : raise ValueError ( 'Count must be at least one' ) return _PAT_JOIN . join ([ inner_pattern ] * count )","title":"build()"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild.index","text":"index ( count = 1 ) Return pattern that matches a specific number of nested lists in the cached data. Source code in pytest_cache_assert/_check_assert/assert_rules.py @classmethod def index ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches a specific number of nested lists in the cached data.\"\"\" return cls . build ( r '\\d+' , count )","title":"index()"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild.keys","text":"keys ( count = 1 ) Return pattern that matches a specific number of nested dictionary keys. Source code in pytest_cache_assert/_check_assert/assert_rules.py @classmethod def keys ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches a specific number of nested dictionary keys.\"\"\" return cls . build ( r '[^\\]]+' , count )","title":"keys()"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild.recur","text":"recur ( count = 1 ) Return pattern that matches any level of nested dictionary keys or lists indices. Source code in pytest_cache_assert/_check_assert/assert_rules.py @classmethod def recur ( cls , count : int = 1 ) -> str : \"\"\"Return pattern that matches any level of nested dictionary keys or lists indices.\"\"\" return cls . build ( r '.+' , count )","title":"recur()"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.check_exact","text":"check_exact ( old , new ) Check for value equality. PARAMETER DESCRIPTION old the old value TYPE: T_DIFF new the new value TYPE: T_DIFF RETURNS DESCRIPTION bool True if both values are the exact same TYPE: bool Source code in pytest_cache_assert/_check_assert/assert_rules.py @beartype def check_exact ( old : T_DIFF , new : T_DIFF ) -> bool : \"\"\"Check for value equality. Args: old: the old value new: the new value Returns: bool: True if both values are the exact same \"\"\" return old == new # type: ignore[no-any-return]","title":"check_exact()"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.check_suppress","text":"check_suppress ( old , new ) Return True to suppress differences. PARAMETER DESCRIPTION old the old value TYPE: T_DIFF new the new value TYPE: T_DIFF RETURNS DESCRIPTION bool Always True TYPE: bool Source code in pytest_cache_assert/_check_assert/assert_rules.py @beartype def check_suppress ( old : T_DIFF , new : T_DIFF ) -> bool : \"\"\"Return True to suppress differences. Args: old: the old value new: the new value Returns: bool: Always True \"\"\" return True","title":"check_suppress()"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.check_type","text":"check_type ( old , new ) Check if both values are the exact same or same non-string type. Will attempt conversion from string. PARAMETER DESCRIPTION old the old value TYPE: T_DIFF new the new value TYPE: T_DIFF RETURNS DESCRIPTION bool True if both values are the same kind TYPE: bool Source code in pytest_cache_assert/_check_assert/assert_rules.py @beartype def check_type ( old : T_DIFF , new : T_DIFF ) -> bool : \"\"\"Check if both values are the exact same or same non-string type. Will attempt conversion from string. Args: old: the old value new: the new value Returns: bool: True if both values are the same kind \"\"\" if ( check_exact ( old = old , new = new ) # Catches if both null, etc. or ( not isinstance ( old , str ) and isinstance ( old , type ( new ))) ): return True return _try_type_coercion ( old = old , new = new )","title":"check_type()"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.gen_check_date_proximity","text":"gen_check_date_proximity ( time_delta , comparator = Comparator . WITHIN ) Generate a AssertRule check for date within the specified range. PARAMETER DESCRIPTION time_delta timedelta to use for checking that the new data is TYPE: timedelta comparator defaults to Comparator.WITHIN. Can make directional by setting LTE or GTE TYPE: Comparator DEFAULT: Comparator.WITHIN RETURNS DESCRIPTION Callable [[ T_DIFF , T_DIFF ], bool ] Callable[[T_DIFF, T_DIFF], bool]: AssertRule check Source code in pytest_cache_assert/_check_assert/assert_rules.py @beartype def gen_check_date_proximity ( time_delta : timedelta , comparator : Comparator = Comparator . WITHIN , ) -> Callable [[ T_DIFF , T_DIFF ], bool ]: \"\"\"Generate a AssertRule check for date within the specified range. Args: time_delta: timedelta to use for checking that the new data is comparator: defaults to Comparator.WITHIN. Can make directional by setting LTE or GTE Returns: Callable[[T_DIFF, T_DIFF], bool]: AssertRule check \"\"\" return partial ( _check_date_proximity , time_delta = time_delta , comparator = comparator )","title":"gen_check_date_proximity()"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.gen_check_date_range","text":"gen_check_date_range ( min_date = None , max_date = None ) Generate a AssertRule check for date within the specified range. PARAMETER DESCRIPTION min_date optional minimum datetime TYPE: Optional [ datetime ] DEFAULT: None max_date optional maximum datetime TYPE: Optional [ datetime ] DEFAULT: None RETURNS DESCRIPTION Callable [[ T_DIFF , T_DIFF ], bool ] Callable[[T_DIFF, T_DIFF], bool]: AssertRule check Source code in pytest_cache_assert/_check_assert/assert_rules.py @beartype def gen_check_date_range ( min_date : Optional [ datetime ] = None , max_date : Optional [ datetime ] = None , ) -> Callable [[ T_DIFF , T_DIFF ], bool ]: \"\"\"Generate a AssertRule check for date within the specified range. Args: min_date: optional minimum datetime max_date: optional maximum datetime Returns: Callable[[T_DIFF, T_DIFF], bool]: AssertRule check \"\"\" return partial ( _check_date_range , min_date = min_date , max_date = max_date )","title":"gen_check_date_range()"},{"location":"reference/pytest_cache_assert/_check_assert/cache_store/","text":"Representative class of the Cache Data Store. Classes \u2693\ufe0e LocalJSONCacheStore \u2693\ufe0e Implementation of the CacheStore interface for a local JSON store. Source code in pytest_cache_assert/_check_assert/cache_store.py class LocalJSONCacheStore : \"\"\"Implementation of the CacheStore interface for a local JSON store.\"\"\" @staticmethod @beartype def initialize ( path_cache_dir : Optional [ Path ], converters : Optional [ List [ Converter ]] = None ) -> None : if converters : register_user_converters ( converters ) if path_cache_dir : init_cache ( path_cache_dir ) @staticmethod @beartype def serialize ( data : Any ) -> Any : return make_diffable ( data = data ) @staticmethod @beartype def write ( path_cache_file : Path , * , metadata : Optional [ Dict ], # type: ignore[type-arg] test_data : Any , always_write : bool = False , ) -> None : write_cache_data ( path_cache_file = path_cache_file , metadata = metadata , test_data = test_data , always_write = always_write , ) @staticmethod @beartype def read_cached_data ( path_cache_file : Path ) -> Any : return load_cached_data ( path_cache_file ) Functions \u2693\ufe0e","title":"cache_store"},{"location":"reference/pytest_cache_assert/_check_assert/cache_store/#pytest_cache_assert._check_assert.cache_store-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/_check_assert/cache_store/#pytest_cache_assert._check_assert.cache_store.LocalJSONCacheStore","text":"Implementation of the CacheStore interface for a local JSON store. Source code in pytest_cache_assert/_check_assert/cache_store.py class LocalJSONCacheStore : \"\"\"Implementation of the CacheStore interface for a local JSON store.\"\"\" @staticmethod @beartype def initialize ( path_cache_dir : Optional [ Path ], converters : Optional [ List [ Converter ]] = None ) -> None : if converters : register_user_converters ( converters ) if path_cache_dir : init_cache ( path_cache_dir ) @staticmethod @beartype def serialize ( data : Any ) -> Any : return make_diffable ( data = data ) @staticmethod @beartype def write ( path_cache_file : Path , * , metadata : Optional [ Dict ], # type: ignore[type-arg] test_data : Any , always_write : bool = False , ) -> None : write_cache_data ( path_cache_file = path_cache_file , metadata = metadata , test_data = test_data , always_write = always_write , ) @staticmethod @beartype def read_cached_data ( path_cache_file : Path ) -> Any : return load_cached_data ( path_cache_file )","title":"LocalJSONCacheStore"},{"location":"reference/pytest_cache_assert/_check_assert/cache_store/#pytest_cache_assert._check_assert.cache_store-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/_check_assert/caching/","text":"Utilities for managing the cache. Attributes \u2693\ufe0e Classes \u2693\ufe0e Functions \u2693\ufe0e init_cache \u2693\ufe0e init_cache ( path_cache_dir ) Ensure that the cache directory exists and add the README. PARAMETER DESCRIPTION path_cache_dir location of the cache directory TYPE: Path Source code in pytest_cache_assert/_check_assert/caching.py @beartype def init_cache ( path_cache_dir : Path ) -> None : \"\"\"Ensure that the cache directory exists and add the README. Args: path_cache_dir: location of the cache directory \"\"\" path_cache_dir . mkdir ( exist_ok = True , parents = True ) ( path_cache_dir / 'README.md' ) . write_text ( CACHE_README_TEXT ) load_cached_data \u2693\ufe0e load_cached_data ( path_cache_file ) Cache the specified data. PARAMETER DESCRIPTION path_cache_file location of the cache file to write TYPE: Path RETURNS DESCRIPTION Any loaded data from cache file TYPE: Any Source code in pytest_cache_assert/_check_assert/caching.py @beartype def load_cached_data ( path_cache_file : Path ) -> Any : \"\"\"Cache the specified data. Args: path_cache_file: location of the cache file to write Returns: Any: loaded data from cache file \"\"\" if path_cache_file . is_file (): return _read_full_cache ( path_cache_file )[ KEY_NAME_DATA ] raise NoCacheError ( f 'No cache for: { path_cache_file } ' ) write_cache_data \u2693\ufe0e write_cache_data ( path_cache_file , * , metadata , test_data , always_write = False ) Cache the specified data. PARAMETER DESCRIPTION path_cache_file location of the cache file to write TYPE: Path metadata optional dictionary for storing in the cache file TYPE: Optional [ Dict ] test_data arbitrary test data to store TYPE: Any always_write if True, overwrite the cached data TYPE: bool DEFAULT: False Source code in pytest_cache_assert/_check_assert/caching.py @beartype def write_cache_data ( path_cache_file : Path , * , metadata : Optional [ Dict ], # type: ignore[type-arg] test_data : Any , always_write : bool = False , ) -> None : \"\"\"Cache the specified data. Args: path_cache_file: location of the cache file to write metadata: optional dictionary for storing in the cache file test_data: arbitrary test data to store always_write: if True, overwrite the cached data \"\"\" metadata = make_diffable ( metadata or {}) meta = [ metadata or {}] if path_cache_file . is_file (): old_cache_dict = _read_full_cache ( path_cache_file ) old_meta = old_cache_dict [ KEY_NAME_META ] meta = _merge_metadata ( meta [ 0 ], old_meta ) if not always_write : # Only change test_data if `always_write` test_data = old_cache_dict [ KEY_NAME_DATA ] cache_dict = { KEY_NAME_META : meta , KEY_NAME_DATA : test_data } path_cache_file . parent . mkdir ( exist_ok = True , parents = True ) path_cache_file . write_text ( pretty_dumps ( cache_dict ))","title":"caching"},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching-attributes","text":"","title":"Attributes"},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching.init_cache","text":"init_cache ( path_cache_dir ) Ensure that the cache directory exists and add the README. PARAMETER DESCRIPTION path_cache_dir location of the cache directory TYPE: Path Source code in pytest_cache_assert/_check_assert/caching.py @beartype def init_cache ( path_cache_dir : Path ) -> None : \"\"\"Ensure that the cache directory exists and add the README. Args: path_cache_dir: location of the cache directory \"\"\" path_cache_dir . mkdir ( exist_ok = True , parents = True ) ( path_cache_dir / 'README.md' ) . write_text ( CACHE_README_TEXT )","title":"init_cache()"},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching.load_cached_data","text":"load_cached_data ( path_cache_file ) Cache the specified data. PARAMETER DESCRIPTION path_cache_file location of the cache file to write TYPE: Path RETURNS DESCRIPTION Any loaded data from cache file TYPE: Any Source code in pytest_cache_assert/_check_assert/caching.py @beartype def load_cached_data ( path_cache_file : Path ) -> Any : \"\"\"Cache the specified data. Args: path_cache_file: location of the cache file to write Returns: Any: loaded data from cache file \"\"\" if path_cache_file . is_file (): return _read_full_cache ( path_cache_file )[ KEY_NAME_DATA ] raise NoCacheError ( f 'No cache for: { path_cache_file } ' )","title":"load_cached_data()"},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching.write_cache_data","text":"write_cache_data ( path_cache_file , * , metadata , test_data , always_write = False ) Cache the specified data. PARAMETER DESCRIPTION path_cache_file location of the cache file to write TYPE: Path metadata optional dictionary for storing in the cache file TYPE: Optional [ Dict ] test_data arbitrary test data to store TYPE: Any always_write if True, overwrite the cached data TYPE: bool DEFAULT: False Source code in pytest_cache_assert/_check_assert/caching.py @beartype def write_cache_data ( path_cache_file : Path , * , metadata : Optional [ Dict ], # type: ignore[type-arg] test_data : Any , always_write : bool = False , ) -> None : \"\"\"Cache the specified data. Args: path_cache_file: location of the cache file to write metadata: optional dictionary for storing in the cache file test_data: arbitrary test data to store always_write: if True, overwrite the cached data \"\"\" metadata = make_diffable ( metadata or {}) meta = [ metadata or {}] if path_cache_file . is_file (): old_cache_dict = _read_full_cache ( path_cache_file ) old_meta = old_cache_dict [ KEY_NAME_META ] meta = _merge_metadata ( meta [ 0 ], old_meta ) if not always_write : # Only change test_data if `always_write` test_data = old_cache_dict [ KEY_NAME_DATA ] cache_dict = { KEY_NAME_META : meta , KEY_NAME_DATA : test_data } path_cache_file . parent . mkdir ( exist_ok = True , parents = True ) path_cache_file . write_text ( pretty_dumps ( cache_dict ))","title":"write_cache_data()"},{"location":"reference/pytest_cache_assert/_check_assert/config/","text":"Configuration settings. Attributes \u2693\ufe0e retrieve module-attribute \u2693\ufe0e retrieve = _cache_assert_container . retrieve Alias for exported function. Classes \u2693\ufe0e CacheAssertContainerKeys \u2693\ufe0e Bases: Enum Enum of keys used in _cache_assert_container . Source code in pytest_cache_assert/_check_assert/config.py class CacheAssertContainerKeys ( Enum ): # noqa: H601 \"\"\"Enum of keys used in `_cache_assert_container`.\"\"\" CONFIG = '__config__'","title":"config"},{"location":"reference/pytest_cache_assert/_check_assert/config/#pytest_cache_assert._check_assert.config-attributes","text":"","title":"Attributes"},{"location":"reference/pytest_cache_assert/_check_assert/config/#pytest_cache_assert._check_assert.config.retrieve","text":"retrieve = _cache_assert_container . retrieve Alias for exported function.","title":"retrieve"},{"location":"reference/pytest_cache_assert/_check_assert/config/#pytest_cache_assert._check_assert.config-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/_check_assert/config/#pytest_cache_assert._check_assert.config.CacheAssertContainerKeys","text":"Bases: Enum Enum of keys used in _cache_assert_container . Source code in pytest_cache_assert/_check_assert/config.py class CacheAssertContainerKeys ( Enum ): # noqa: H601 \"\"\"Enum of keys used in `_cache_assert_container`.\"\"\" CONFIG = '__config__'","title":"CacheAssertContainerKeys"},{"location":"reference/pytest_cache_assert/_check_assert/constants/","text":"Constants. Attributes \u2693\ufe0e CACHE_README_TEXT module-attribute \u2693\ufe0e CACHE_README_TEXT = '# Pytest Assert Cache \\n\\n This folder is automatically generated by `pytest_cache_assert`. \\n\\n Files can be regenerated by deleting and allowing `pytest_cache_assert` to recreate them when next running the test suite. \\n ' README content for the cache directory. DEF_CACHE_DIR_NAME module-attribute \u2693\ufe0e DEF_CACHE_DIR_NAME = 'assert-cache' Default pytest_assert_cache directory name. KEY_NAME_DATA module-attribute \u2693\ufe0e KEY_NAME_DATA = '_json' Key for cached data. KEY_NAME_META module-attribute \u2693\ufe0e KEY_NAME_META = '_info' Key for metadata. T_CONVERTER module-attribute \u2693\ufe0e T_CONVERTER = Callable [[ Any ], T_SER ] Generic type for converters with a single argument. T_DIFF module-attribute \u2693\ufe0e T_DIFF = Any Possible Old or New difference type. T_SER module-attribute \u2693\ufe0e T_SER = Optional [ Union [ str , int , float , bool , List , Dict ]] JSON-Serializable types.","title":"constants"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants-attributes","text":"","title":"Attributes"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.CACHE_README_TEXT","text":"CACHE_README_TEXT = '# Pytest Assert Cache \\n\\n This folder is automatically generated by `pytest_cache_assert`. \\n\\n Files can be regenerated by deleting and allowing `pytest_cache_assert` to recreate them when next running the test suite. \\n ' README content for the cache directory.","title":"CACHE_README_TEXT"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.DEF_CACHE_DIR_NAME","text":"DEF_CACHE_DIR_NAME = 'assert-cache' Default pytest_assert_cache directory name.","title":"DEF_CACHE_DIR_NAME"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.KEY_NAME_DATA","text":"KEY_NAME_DATA = '_json' Key for cached data.","title":"KEY_NAME_DATA"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.KEY_NAME_META","text":"KEY_NAME_META = '_info' Key for metadata.","title":"KEY_NAME_META"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.T_CONVERTER","text":"T_CONVERTER = Callable [[ Any ], T_SER ] Generic type for converters with a single argument.","title":"T_CONVERTER"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.T_DIFF","text":"T_DIFF = Any Possible Old or New difference type.","title":"T_DIFF"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.T_SER","text":"T_SER = Optional [ Union [ str , int , float , bool , List , Dict ]] JSON-Serializable types.","title":"T_SER"},{"location":"reference/pytest_cache_assert/_check_assert/converter/","text":"Pytest Cache Assert Configuration Object. Attributes \u2693\ufe0e Classes \u2693\ufe0e Converter \u2693\ufe0e Bases: BaseModel User-specific converters to extend the default cache_store . Source code in pytest_cache_assert/_check_assert/converter.py class Converter ( BaseModel , frozen = True ): \"\"\"User-specific converters to extend the default `cache_store`.\"\"\" types : List [ Any ] func : T_CONVERTER","title":"converter"},{"location":"reference/pytest_cache_assert/_check_assert/converter/#pytest_cache_assert._check_assert.converter-attributes","text":"","title":"Attributes"},{"location":"reference/pytest_cache_assert/_check_assert/converter/#pytest_cache_assert._check_assert.converter-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/_check_assert/converter/#pytest_cache_assert._check_assert.converter.Converter","text":"Bases: BaseModel User-specific converters to extend the default cache_store . Source code in pytest_cache_assert/_check_assert/converter.py class Converter ( BaseModel , frozen = True ): \"\"\"User-specific converters to extend the default `cache_store`.\"\"\" types : List [ Any ] func : T_CONVERTER","title":"Converter"},{"location":"reference/pytest_cache_assert/_check_assert/differ/","text":"Dictionary Differ. Attributes \u2693\ufe0e Classes \u2693\ufe0e DiffResults \u2693\ufe0e Bases: BaseModel Result from calculating the diff. Source code in pytest_cache_assert/_check_assert/differ.py class DiffResults ( BaseModel ): \"\"\"Result from calculating the diff.\"\"\" results : Dict # type: ignore[type-arg] @beartype def to_dict ( self ) -> Dict : # type: ignore[type-arg] return self . results @beartype def append ( self , assert_rule : AssertRule , result : Dict ) -> None : # type: ignore[type-arg] self . results [ f 'For { assert_rule } ' ] = result Functions \u2693\ufe0e diff_with_rules \u2693\ufe0e diff_with_rules ( * , old_dict , new_dict , assert_rules ) Determine the differences between two dictionaries. PARAMETER DESCRIPTION old_dict old dictionary (typically cached one) TYPE: T_DIFF new_dict new dictionary (typically test data) TYPE: T_DIFF assert_rules list of assert rules to ignore certain differences TYPE: List [ AssertRule ] RETURNS DESCRIPTION DiffResults Diff Object TYPE: DiffResults Source code in pytest_cache_assert/_check_assert/differ.py @beartype def diff_with_rules ( * , old_dict : T_DIFF , new_dict : T_DIFF , assert_rules : List [ AssertRule ]) -> DiffResults : \"\"\"Determine the differences between two dictionaries. Args: old_dict: old dictionary (typically cached one) new_dict: new dictionary (typically test data) assert_rules: list of assert rules to ignore certain differences Returns: DiffResults: Diff Object \"\"\" key_str = 'str' key_re = 'regex' collector : Dict [ str , List [ Union [ str , Pattern [ str ]]]] = { key_str : [], key_re : []} for ar in assert_rules : collector [ key_re if ar . is_regex () else key_str ] . append ( ar . pattern ) diff_result = _raw_diff ( old_dict = old_dict , new_dict = new_dict , exclude_paths = collector [ key_str ], exclude_regex_paths = collector [ key_re ], ) for ar in assert_rules : paths = [] for data_set in [ old_dict , new_dict ]: ds = DeepSearch ( data_set , ar . pattern , use_regexp = ar . is_regex ()) paths . extend ([ * ds . get ( 'matched_paths' , {})]) for pth in set ( paths ): new_value , old_value = NotFound (), NotFound () with suppress ( KeyError ): old_value = extract ( old_dict , pth ) with suppress ( KeyError ): new_value = extract ( new_dict , pth ) if not ar . func ( old_value , new_value ): diff_result . append ( ar , { 'old_value' : old_value , 'new_value' : new_value }) return diff_result","title":"differ"},{"location":"reference/pytest_cache_assert/_check_assert/differ/#pytest_cache_assert._check_assert.differ-attributes","text":"","title":"Attributes"},{"location":"reference/pytest_cache_assert/_check_assert/differ/#pytest_cache_assert._check_assert.differ-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/_check_assert/differ/#pytest_cache_assert._check_assert.differ.DiffResults","text":"Bases: BaseModel Result from calculating the diff. Source code in pytest_cache_assert/_check_assert/differ.py class DiffResults ( BaseModel ): \"\"\"Result from calculating the diff.\"\"\" results : Dict # type: ignore[type-arg] @beartype def to_dict ( self ) -> Dict : # type: ignore[type-arg] return self . results @beartype def append ( self , assert_rule : AssertRule , result : Dict ) -> None : # type: ignore[type-arg] self . results [ f 'For { assert_rule } ' ] = result","title":"DiffResults"},{"location":"reference/pytest_cache_assert/_check_assert/differ/#pytest_cache_assert._check_assert.differ-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/_check_assert/differ/#pytest_cache_assert._check_assert.differ.diff_with_rules","text":"diff_with_rules ( * , old_dict , new_dict , assert_rules ) Determine the differences between two dictionaries. PARAMETER DESCRIPTION old_dict old dictionary (typically cached one) TYPE: T_DIFF new_dict new dictionary (typically test data) TYPE: T_DIFF assert_rules list of assert rules to ignore certain differences TYPE: List [ AssertRule ] RETURNS DESCRIPTION DiffResults Diff Object TYPE: DiffResults Source code in pytest_cache_assert/_check_assert/differ.py @beartype def diff_with_rules ( * , old_dict : T_DIFF , new_dict : T_DIFF , assert_rules : List [ AssertRule ]) -> DiffResults : \"\"\"Determine the differences between two dictionaries. Args: old_dict: old dictionary (typically cached one) new_dict: new dictionary (typically test data) assert_rules: list of assert rules to ignore certain differences Returns: DiffResults: Diff Object \"\"\" key_str = 'str' key_re = 'regex' collector : Dict [ str , List [ Union [ str , Pattern [ str ]]]] = { key_str : [], key_re : []} for ar in assert_rules : collector [ key_re if ar . is_regex () else key_str ] . append ( ar . pattern ) diff_result = _raw_diff ( old_dict = old_dict , new_dict = new_dict , exclude_paths = collector [ key_str ], exclude_regex_paths = collector [ key_re ], ) for ar in assert_rules : paths = [] for data_set in [ old_dict , new_dict ]: ds = DeepSearch ( data_set , ar . pattern , use_regexp = ar . is_regex ()) paths . extend ([ * ds . get ( 'matched_paths' , {})]) for pth in set ( paths ): new_value , old_value = NotFound (), NotFound () with suppress ( KeyError ): old_value = extract ( old_dict , pth ) with suppress ( KeyError ): new_value = extract ( new_dict , pth ) if not ar . func ( old_value , new_value ): diff_result . append ( ar , { 'old_value' : old_value , 'new_value' : new_value }) return diff_result","title":"diff_with_rules()"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/","text":"Generate nice error messages. Classes \u2693\ufe0e NoCacheError \u2693\ufe0e Bases: FileNotFoundError Custom Assertion when no cached data is available for read. Source code in pytest_cache_assert/_check_assert/error_message.py class NoCacheError ( FileNotFoundError ): \"\"\"Custom Assertion when no cached data is available for read.\"\"\" ... RichAssertionError \u2693\ufe0e Bases: AssertionError Custom AssertionError with additional error_info . Source code in pytest_cache_assert/_check_assert/error_message.py class RichAssertionError ( AssertionError ): \"\"\"Custom AssertionError with additional `error_info`.\"\"\" def __init__ ( self , * args : Any , error_info : Any = None ) -> None : \"\"\"Store the error_info for later access.\"\"\" # noqa: DAR101 super () . __init__ ( * args ) self . error_info = error_info @classmethod def create_message ( cls , test_data : Any , cached_data : Any , path_cache_file : Path , diff_results : DiffResults , ) -> str : \"\"\"Create the error message. Args: test_data: the test data cached_data: the cached data path_cache_file: the path to the cache file diff_results: the diff results Returns: str: pleasant error message \"\"\" @beartype def fmt_line ( prefix : str , data : Any ) -> str : indented_data = ( ' \\n ' + ' ' * len ( prefix )) . join ( pformat ( data ) . split ( ' \\n ' )) return f ' { prefix }{ indented_data } ' diff_prefix = '> Differences: ' line_diff = fmt_line ( diff_prefix , diff_results . to_dict ()) return f ' \\n > Found differences with: { path_cache_file } \\n { line_diff } \\n ' Functions \u2693\ufe0e __init__ \u2693\ufe0e __init__ ( * args , error_info = None ) Store the error_info for later access. Source code in pytest_cache_assert/_check_assert/error_message.py def __init__ ( self , * args : Any , error_info : Any = None ) -> None : \"\"\"Store the error_info for later access.\"\"\" # noqa: DAR101 super () . __init__ ( * args ) self . error_info = error_info create_message classmethod \u2693\ufe0e create_message ( test_data , cached_data , path_cache_file , diff_results ) Create the error message. PARAMETER DESCRIPTION test_data the test data TYPE: Any cached_data the cached data TYPE: Any path_cache_file the path to the cache file TYPE: Path diff_results the diff results TYPE: DiffResults RETURNS DESCRIPTION str pleasant error message TYPE: str Source code in pytest_cache_assert/_check_assert/error_message.py @classmethod def create_message ( cls , test_data : Any , cached_data : Any , path_cache_file : Path , diff_results : DiffResults , ) -> str : \"\"\"Create the error message. Args: test_data: the test data cached_data: the cached data path_cache_file: the path to the cache file diff_results: the diff results Returns: str: pleasant error message \"\"\" @beartype def fmt_line ( prefix : str , data : Any ) -> str : indented_data = ( ' \\n ' + ' ' * len ( prefix )) . join ( pformat ( data ) . split ( ' \\n ' )) return f ' { prefix }{ indented_data } ' diff_prefix = '> Differences: ' line_diff = fmt_line ( diff_prefix , diff_results . to_dict ()) return f ' \\n > Found differences with: { path_cache_file } \\n { line_diff } \\n '","title":"error_message"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message.NoCacheError","text":"Bases: FileNotFoundError Custom Assertion when no cached data is available for read. Source code in pytest_cache_assert/_check_assert/error_message.py class NoCacheError ( FileNotFoundError ): \"\"\"Custom Assertion when no cached data is available for read.\"\"\" ...","title":"NoCacheError"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message.RichAssertionError","text":"Bases: AssertionError Custom AssertionError with additional error_info . Source code in pytest_cache_assert/_check_assert/error_message.py class RichAssertionError ( AssertionError ): \"\"\"Custom AssertionError with additional `error_info`.\"\"\" def __init__ ( self , * args : Any , error_info : Any = None ) -> None : \"\"\"Store the error_info for later access.\"\"\" # noqa: DAR101 super () . __init__ ( * args ) self . error_info = error_info @classmethod def create_message ( cls , test_data : Any , cached_data : Any , path_cache_file : Path , diff_results : DiffResults , ) -> str : \"\"\"Create the error message. Args: test_data: the test data cached_data: the cached data path_cache_file: the path to the cache file diff_results: the diff results Returns: str: pleasant error message \"\"\" @beartype def fmt_line ( prefix : str , data : Any ) -> str : indented_data = ( ' \\n ' + ' ' * len ( prefix )) . join ( pformat ( data ) . split ( ' \\n ' )) return f ' { prefix }{ indented_data } ' diff_prefix = '> Differences: ' line_diff = fmt_line ( diff_prefix , diff_results . to_dict ()) return f ' \\n > Found differences with: { path_cache_file } \\n { line_diff } \\n '","title":"RichAssertionError"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message.RichAssertionError-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message.RichAssertionError.__init__","text":"__init__ ( * args , error_info = None ) Store the error_info for later access. Source code in pytest_cache_assert/_check_assert/error_message.py def __init__ ( self , * args : Any , error_info : Any = None ) -> None : \"\"\"Store the error_info for later access.\"\"\" # noqa: DAR101 super () . __init__ ( * args ) self . error_info = error_info","title":"__init__()"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message.RichAssertionError.create_message","text":"create_message ( test_data , cached_data , path_cache_file , diff_results ) Create the error message. PARAMETER DESCRIPTION test_data the test data TYPE: Any cached_data the cached data TYPE: Any path_cache_file the path to the cache file TYPE: Path diff_results the diff results TYPE: DiffResults RETURNS DESCRIPTION str pleasant error message TYPE: str Source code in pytest_cache_assert/_check_assert/error_message.py @classmethod def create_message ( cls , test_data : Any , cached_data : Any , path_cache_file : Path , diff_results : DiffResults , ) -> str : \"\"\"Create the error message. Args: test_data: the test data cached_data: the cached data path_cache_file: the path to the cache file diff_results: the diff results Returns: str: pleasant error message \"\"\" @beartype def fmt_line ( prefix : str , data : Any ) -> str : indented_data = ( ' \\n ' + ' ' * len ( prefix )) . join ( pformat ( data ) . split ( ' \\n ' )) return f ' { prefix }{ indented_data } ' diff_prefix = '> Differences: ' line_diff = fmt_line ( diff_prefix , diff_results . to_dict ()) return f ' \\n > Found differences with: { path_cache_file } \\n { line_diff } \\n '","title":"create_message()"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/","text":"Implement a serializer for caching data to and from version controlled files. Attributes \u2693\ufe0e Classes \u2693\ufe0e Unconvertable \u2693\ufe0e Bases: ValueError Custom Error to indicate conversion failure. Source code in pytest_cache_assert/_check_assert/serializer.py class Unconvertable ( ValueError ): \"\"\"Custom Error to indicate conversion failure.\"\"\" ... Functions \u2693\ufe0e dumps \u2693\ufe0e dumps ( obj , sort_keys = False , indent = 0 ) Serialize object to str. PARAMETER DESCRIPTION obj data to serialize TYPE: Any sort_keys if True, order keys before serializing TYPE: bool DEFAULT: False indent indent for pretty-printing. Default is no extra whitespace TYPE: int DEFAULT: 0 RETURNS DESCRIPTION str serialized data TYPE: str RAISES DESCRIPTION Unconvertable when serialization fails Source code in pytest_cache_assert/_check_assert/serializer.py @beartype def dumps ( obj : Any , sort_keys : bool = False , indent : int = 0 ) -> str : \"\"\"Serialize object to str. Args: obj: data to serialize sort_keys: if True, order keys before serializing indent: indent for pretty-printing. Default is no extra whitespace Returns: str: serialized data Raises: Unconvertable: when serialization fails \"\"\" try : return json . dumps ( obj , sort_keys = sort_keys , indent = indent or None , cls = _CacheAssertSerializer ) except Unconvertable as exc : raise Unconvertable ( f 'Conversion error. Try specifying new converters in AssertConfig to fix: { exc } ' ) from exc loads \u2693\ufe0e loads ( raw ) Deserialize arbitrary JSON data back to Python types. PARAMETER DESCRIPTION raw raw string JSON TYPE: str RETURNS DESCRIPTION T_DIFF DiffResults-safe data TYPE: T_DIFF Source code in pytest_cache_assert/_check_assert/serializer.py @beartype def loads ( raw : str ) -> T_DIFF : \"\"\"Deserialize arbitrary JSON data back to Python types. Args: raw: raw string JSON Returns: T_DIFF: DiffResults-safe data \"\"\" return json . loads ( raw ) make_diffable \u2693\ufe0e make_diffable ( data ) Convert raw object to diffable types for assertion checks. PARAMETER DESCRIPTION data data to serialize TYPE: Any RETURNS DESCRIPTION T_DIFF DiffResults-safe data TYPE: T_DIFF Source code in pytest_cache_assert/_check_assert/serializer.py @beartype def make_diffable ( data : Any ) -> T_DIFF : \"\"\"Convert raw object to diffable types for assertion checks. Args: data: data to serialize Returns: T_DIFF: DiffResults-safe data \"\"\" return loads ( dumps ( data )) pretty_dumps \u2693\ufe0e pretty_dumps ( obj ) Serialize object to a pretty-printable str. PARAMETER DESCRIPTION obj data to serialize TYPE: Any RETURNS DESCRIPTION str serialized data TYPE: str Source code in pytest_cache_assert/_check_assert/serializer.py @beartype def pretty_dumps ( obj : Any ) -> str : \"\"\"Serialize object to a pretty-printable str. Args: obj: data to serialize Returns: str: serialized data \"\"\" return dumps ( obj , sort_keys = True , indent = 2 ) . strip () + ' \\n ' register_user_converters \u2693\ufe0e register_user_converters ( converters ) Register the user-specified converters. Source code in pytest_cache_assert/_check_assert/serializer.py @beartype def register_user_converters ( converters : List [ Converter ]) -> None : \"\"\"Register the user-specified converters.\"\"\" for converter in converters : _CONVERTERS . register ( converter . types , converter . func )","title":"serializer"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer-attributes","text":"","title":"Attributes"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.Unconvertable","text":"Bases: ValueError Custom Error to indicate conversion failure. Source code in pytest_cache_assert/_check_assert/serializer.py class Unconvertable ( ValueError ): \"\"\"Custom Error to indicate conversion failure.\"\"\" ...","title":"Unconvertable"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.dumps","text":"dumps ( obj , sort_keys = False , indent = 0 ) Serialize object to str. PARAMETER DESCRIPTION obj data to serialize TYPE: Any sort_keys if True, order keys before serializing TYPE: bool DEFAULT: False indent indent for pretty-printing. Default is no extra whitespace TYPE: int DEFAULT: 0 RETURNS DESCRIPTION str serialized data TYPE: str RAISES DESCRIPTION Unconvertable when serialization fails Source code in pytest_cache_assert/_check_assert/serializer.py @beartype def dumps ( obj : Any , sort_keys : bool = False , indent : int = 0 ) -> str : \"\"\"Serialize object to str. Args: obj: data to serialize sort_keys: if True, order keys before serializing indent: indent for pretty-printing. Default is no extra whitespace Returns: str: serialized data Raises: Unconvertable: when serialization fails \"\"\" try : return json . dumps ( obj , sort_keys = sort_keys , indent = indent or None , cls = _CacheAssertSerializer ) except Unconvertable as exc : raise Unconvertable ( f 'Conversion error. Try specifying new converters in AssertConfig to fix: { exc } ' ) from exc","title":"dumps()"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.loads","text":"loads ( raw ) Deserialize arbitrary JSON data back to Python types. PARAMETER DESCRIPTION raw raw string JSON TYPE: str RETURNS DESCRIPTION T_DIFF DiffResults-safe data TYPE: T_DIFF Source code in pytest_cache_assert/_check_assert/serializer.py @beartype def loads ( raw : str ) -> T_DIFF : \"\"\"Deserialize arbitrary JSON data back to Python types. Args: raw: raw string JSON Returns: T_DIFF: DiffResults-safe data \"\"\" return json . loads ( raw )","title":"loads()"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.make_diffable","text":"make_diffable ( data ) Convert raw object to diffable types for assertion checks. PARAMETER DESCRIPTION data data to serialize TYPE: Any RETURNS DESCRIPTION T_DIFF DiffResults-safe data TYPE: T_DIFF Source code in pytest_cache_assert/_check_assert/serializer.py @beartype def make_diffable ( data : Any ) -> T_DIFF : \"\"\"Convert raw object to diffable types for assertion checks. Args: data: data to serialize Returns: T_DIFF: DiffResults-safe data \"\"\" return loads ( dumps ( data ))","title":"make_diffable()"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.pretty_dumps","text":"pretty_dumps ( obj ) Serialize object to a pretty-printable str. PARAMETER DESCRIPTION obj data to serialize TYPE: Any RETURNS DESCRIPTION str serialized data TYPE: str Source code in pytest_cache_assert/_check_assert/serializer.py @beartype def pretty_dumps ( obj : Any ) -> str : \"\"\"Serialize object to a pretty-printable str. Args: obj: data to serialize Returns: str: serialized data \"\"\" return dumps ( obj , sort_keys = True , indent = 2 ) . strip () + ' \\n '","title":"pretty_dumps()"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.register_user_converters","text":"register_user_converters ( converters ) Register the user-specified converters. Source code in pytest_cache_assert/_check_assert/serializer.py @beartype def register_user_converters ( converters : List [ Converter ]) -> None : \"\"\"Register the user-specified converters.\"\"\" for converter in converters : _CONVERTERS . register ( converter . types , converter . func )","title":"register_user_converters()"},{"location":"reference/pytest_cache_assert/_check_assert/validator/","text":"Override the default validator for determining differences with the cached data. Classes \u2693\ufe0e DictDiffValidator \u2693\ufe0e Default Validator. Source code in pytest_cache_assert/_check_assert/validator.py class DictDiffValidator : \"\"\"Default Validator.\"\"\" @staticmethod @beartype def assertion ( * , test_data : Any , cached_data : Any , assert_rules : List [ AssertRule ], path_cache_file : Optional [ Path ] = None , ) -> None : \"\"\"Validate test data against cached data. Args: test_data: data to compare cached_data: data to compare assert_rules: list of assert rules to apply path_cache_file: optional Path to the cached data Raises: RichAssertionError: if any assertion comparison fails \"\"\" diff_results = diff_with_rules ( old_dict = cached_data , new_dict = test_data , assert_rules = assert_rules or []) if diff_results . to_dict (): kwargs = { 'test_data' : test_data , 'cached_data' : cached_data , 'path_cache_file' : path_cache_file , 'diff_results' : diff_results , } raise RichAssertionError ( RichAssertionError . create_message ( ** kwargs ), error_info = kwargs ) Functions \u2693\ufe0e assertion staticmethod \u2693\ufe0e assertion ( * , test_data , cached_data , assert_rules , path_cache_file = None ) Validate test data against cached data. PARAMETER DESCRIPTION test_data data to compare TYPE: Any cached_data data to compare TYPE: Any assert_rules list of assert rules to apply TYPE: List [ AssertRule ] path_cache_file optional Path to the cached data TYPE: Optional [ Path ] DEFAULT: None RAISES DESCRIPTION RichAssertionError if any assertion comparison fails Source code in pytest_cache_assert/_check_assert/validator.py @staticmethod @beartype def assertion ( * , test_data : Any , cached_data : Any , assert_rules : List [ AssertRule ], path_cache_file : Optional [ Path ] = None , ) -> None : \"\"\"Validate test data against cached data. Args: test_data: data to compare cached_data: data to compare assert_rules: list of assert rules to apply path_cache_file: optional Path to the cached data Raises: RichAssertionError: if any assertion comparison fails \"\"\" diff_results = diff_with_rules ( old_dict = cached_data , new_dict = test_data , assert_rules = assert_rules or []) if diff_results . to_dict (): kwargs = { 'test_data' : test_data , 'cached_data' : cached_data , 'path_cache_file' : path_cache_file , 'diff_results' : diff_results , } raise RichAssertionError ( RichAssertionError . create_message ( ** kwargs ), error_info = kwargs ) ValidatorType \u2693\ufe0e Bases: Protocol Validator Interface. Source code in pytest_cache_assert/_check_assert/validator.py @runtime_checkable class ValidatorType ( Protocol ): \"\"\"Validator Interface.\"\"\" @staticmethod def assertion ( * , test_data : Any , cached_data : Any , assert_rules : List [ AssertRule ], path_cache_file : Optional [ Path ] = None , ) -> None : ... Functions \u2693\ufe0e","title":"validator"},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator-classes","text":"","title":"Classes"},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator.DictDiffValidator","text":"Default Validator. Source code in pytest_cache_assert/_check_assert/validator.py class DictDiffValidator : \"\"\"Default Validator.\"\"\" @staticmethod @beartype def assertion ( * , test_data : Any , cached_data : Any , assert_rules : List [ AssertRule ], path_cache_file : Optional [ Path ] = None , ) -> None : \"\"\"Validate test data against cached data. Args: test_data: data to compare cached_data: data to compare assert_rules: list of assert rules to apply path_cache_file: optional Path to the cached data Raises: RichAssertionError: if any assertion comparison fails \"\"\" diff_results = diff_with_rules ( old_dict = cached_data , new_dict = test_data , assert_rules = assert_rules or []) if diff_results . to_dict (): kwargs = { 'test_data' : test_data , 'cached_data' : cached_data , 'path_cache_file' : path_cache_file , 'diff_results' : diff_results , } raise RichAssertionError ( RichAssertionError . create_message ( ** kwargs ), error_info = kwargs )","title":"DictDiffValidator"},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator.DictDiffValidator-functions","text":"","title":"Functions"},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator.DictDiffValidator.assertion","text":"assertion ( * , test_data , cached_data , assert_rules , path_cache_file = None ) Validate test data against cached data. PARAMETER DESCRIPTION test_data data to compare TYPE: Any cached_data data to compare TYPE: Any assert_rules list of assert rules to apply TYPE: List [ AssertRule ] path_cache_file optional Path to the cached data TYPE: Optional [ Path ] DEFAULT: None RAISES DESCRIPTION RichAssertionError if any assertion comparison fails Source code in pytest_cache_assert/_check_assert/validator.py @staticmethod @beartype def assertion ( * , test_data : Any , cached_data : Any , assert_rules : List [ AssertRule ], path_cache_file : Optional [ Path ] = None , ) -> None : \"\"\"Validate test data against cached data. Args: test_data: data to compare cached_data: data to compare assert_rules: list of assert rules to apply path_cache_file: optional Path to the cached data Raises: RichAssertionError: if any assertion comparison fails \"\"\" diff_results = diff_with_rules ( old_dict = cached_data , new_dict = test_data , assert_rules = assert_rules or []) if diff_results . to_dict (): kwargs = { 'test_data' : test_data , 'cached_data' : cached_data , 'path_cache_file' : path_cache_file , 'diff_results' : diff_results , } raise RichAssertionError ( RichAssertionError . create_message ( ** kwargs ), error_info = kwargs )","title":"assertion()"},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator.ValidatorType","text":"Bases: Protocol Validator Interface. Source code in pytest_cache_assert/_check_assert/validator.py @runtime_checkable class ValidatorType ( Protocol ): \"\"\"Validator Interface.\"\"\" @staticmethod def assertion ( * , test_data : Any , cached_data : Any , assert_rules : List [ AssertRule ], path_cache_file : Optional [ Path ] = None , ) -> None : ...","title":"ValidatorType"},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator-functions","text":"","title":"Functions"}]}