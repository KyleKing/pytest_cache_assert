{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pytest_cache_assert","text":"<p>Cache assertion data to simplify regression testing of complex serializable data</p>"},{"location":"#installation","title":"Installation","text":"<p><code>poetry add pytest_assert_check --dev</code></p>"},{"location":"#usage","title":"Usage","text":"<p>The primary use case of this package is regression testing of large, serializable dictionaries, such as from an API under development.</p> <p>You may have parameterized test cases where you need to assert that the created dictionary stays the same, but you don\u2019t want to manually generate the expected fields and values to compare. Instead you can capture a snapshot of the serialized data and cache the result then use the cached data to check for consistency in repeated test runs. The cached files should be checked into version control, which can be very useful as documentation</p> <p>This package can minimize test case logic, while improving regression testing thoroughness</p> <p>This project was heavily inspired by the excellent pytest-recording</p>"},{"location":"#alternatives","title":"Alternatives","text":"<ul> <li>pytest-recording: this is the package I use and highly recommend for recording and replaying external API communication so that API requests only need to be made once for unit testing (i.e. recording API responses from Github\u2019s API called from a test suite)</li> <li>pytest-snapshot: I only found this package after already releasing a 1.0.0 version of <code>pytest_assert_cache</code>. This package can be more configurable with a user-specified serializer and might be a good alternative. See their documentation for more info</li> <li>snapshottest: This was another find after releasing a 1.0.0 version and would probably be a good alterantive for most users<ul> <li><code>pytest-snapshot</code> is much more configurable, has many more users, and is a better name<ul> <li>I really like the ability to quickly regenerate the cached files with \u2013snapshot-update</li> <li>There is some interesting discussion on how best to handle fields that change between tests</li> </ul> </li> </ul> </li> <li>dirty-equals: broadly check values (i.e. <code>assert result == {'counter': IsPositiveInt, ...}</code>, etc.) rather than accessing and checking each field individual, which makes test easier to write and output errors easier to review</li> </ul>"},{"location":"#basic-example","title":"Basic Example","text":"<p>You\u2019ve created a new project called <code>package_a</code> with one file <code>package_a/source_file.py</code> and test <code>tests/test_file.py</code></p> <pre><code>\"\"\"package_a/source_file.py\"\"\"\nimport sys\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional\nfrom beartype import beartype\nfrom pydantic import BaseModel\nclass User(BaseModel):  # noqa: H601\n\"\"\"Example from pydantic documentation.\"\"\"\nid: int  # noqa: A003,VNE003\nname = 'John Doe'\nsignup_ts: Optional[datetime] = None\nfriends: List[int] = []\n@beartype\ndef create_data(name: str) -&gt; Dict:\n\"\"\"Arbitrary function that returns a dictionary.\n    This demonstration uses pydantic, but any dictionary can be tested!\n    \"\"\"\nreturn User(id=sys.maxsize, name=name).dict()\n</code></pre> <pre><code>\"\"\"tests/test_file.py\"\"\"\nimport pytest\nfrom package_a.source_file import create_data\n@pytest.mark.parametrize('name', ['Test Name 1', 'Test Name 2'])\ndef test_create_data(name, assert_against_cache):\n\"\"\"Basic test of create_data().\"\"\"\nresult = create_data(name=name)\n# One could manually create the expected dictionary\ncache = {'id': 9223372036854775807, 'signup_ts': None, 'friends': [], 'name': name}\nassert result == cache\n# ----------------------------------------------------------------------------------\n# Or utilize the pytest_cache_assert fixture to compare against the last cached version\nassert_against_cache(result)\n</code></pre> <p><code>pytest_cache_assert</code> will automatically create: <code>tests/cache-assert/source_file/test_file/test_create_data-[Test Name 1].json</code> (and <code>test_create_data[Test Name 2].json</code>) for each of the parameters when first run by caching the <code>result</code>. Below is the example for <code>test_create_data-[Test Name 1].json</code></p> <pre><code>{\n\"_info\": [\n{\n\"func_args\": {\n\"name\": \"Test Name 1\"\n},\n\"test_file\": \"test_readme.py\",\n\"test_name\": \"test_create_data\"\n}\n],\n\"_json\": {\n\"friends\": [],\n\"id\": 9223372036854775807,\n\"name\": \"Test Name 1\",\n\"signup_ts\": null\n}\n}\n</code></pre> <p>The cached JSON files must be checked into version control and if needed, can be manually edited or deleted so that they will be regenerated when the test suite is next run</p>"},{"location":"#more-examples","title":"More Examples","text":"<p>In your cached dictionary, you may have variable values with more complex logic to verify, such as dates, UUIDs, etc. These can be selectively ignored, matched-if-null, or some other user-specified check:</p> <pre><code>\"\"\"tests/test_readme_more.py.\"\"\"\nfrom contextlib import suppress\nfrom datetime import datetime, timedelta\nfrom uuid import uuid4\nimport pytest\nfrom pytest_cache_assert import AssertRule, Wild, check_suppress, check_type\ndef test_assert_against_cache_key_rules(assert_against_cache):\n\"\"\"Demonstrate use of `assert_rules`.\"\"\"\nnow = datetime.now()\ncached_data = {\n'date': str(now),\n'nested': {'uuid': str(uuid4())},\n'ignored': {'a': 1, 'b': 2},\n}\ntest_data = {\n'date': str(now + timedelta(hours=3)),\n'nested': {'uuid': str(uuid4())},\n'ignored': {'recursively': {'a': {'b': {'c': 1}}}},\n}\nwith suppress(AssertionError):\n# Ensures that the cache file has been created\nassert_against_cache(cached_data)\nassert_rules = [\n# To ignore values for 'ignored.a' and 'ignored.b', create a rule\n#   Here, we use the wildcard for dictionary keys\nAssertRule.build_re(pattern=['ignored', Wild.recur()], func=check_suppress),\n# Instead of suppressing, the type of data could be resolved and compared\n#   This is useful for datetime or UUID values where we expect variability\nAssertRule(pattern='date', func=check_type),\nAssertRule.build_re(pattern=['nested', 'uuid'], func=check_type),\n# Any \"func\" with arguments 'old' and 'new' can be used as a rule\n]\n# Without assert rules, an AssertionError is raised\nwith pytest.raises(AssertionError):\nassert_against_cache(test_data)\n# But, with the custom logic, the cache assertion check will succeed\nassert_against_cache(test_data, assert_rules=assert_rules)\n</code></pre>"},{"location":"#even-more-examples","title":"Even More Examples","text":"<p>For more example code, see the scripts directory or the tests.</p>"},{"location":"#customization-beta","title":"Customization (<code>beta</code>)","text":"<p>Note: this feature is to be considered <code>beta</code> and may change, however, I will do my best to keep the same interfaces</p> <p>For 2.0.0, <code>pytest_cache_assert</code> was refactored to be more easily customizable with configuration options for not just the cache directory, but also for a way to override how files are named and to override how the cached test data is serialized and validated.</p> <p>With these configuration options, users or 3rd party packages can replace the default package behavior, such as changing the file format for data serialization (<code>yaml</code>, <code>jsonlines</code>, etc.) and/or specifying a different serialization logic. All configuration options are available by creating a <code>cache_assert_config</code> fixture with the provided implementations.</p> <ul> <li>See <code>AssertConfig</code> in <code>plugin.py</code> for configuration options and more information<ul> <li><code>always_write</code>: Always write to the cached file so that diffs can be examined in the user\u2019s VCS.</li> <li><code>cache_dir_rel_path</code>: String relative directory from <code>tests/</code>. Default resolves to <code>tests/assert-cache/</code>.</li> <li><code>cache_store</code>: Configurable class for managing the cache representation. Default is local JSON.</li> <li><code>converters</code>: register functions that handle conversion of unhandled types, such as pandas DataFrames</li> <li><code>validator</code>: Custom validator for identifying and summarizing the deviations from the cache.</li> </ul> </li> </ul> <pre><code>import pytest\nfrom pytest_cache_assert.plugin import AssertConfig\n@pytest.fixture(scope='module')\ndef cache_assert_config():\nreturn AssertConfig(cache_dir_rel_path='custom/cache/dir')\n</code></pre>"},{"location":"#project-status","title":"Project Status","text":"<p>See the <code>Open Issues</code> and/or the CODE_TAG_SUMMARY. For release history, see the CHANGELOG.</p>"},{"location":"#planned-global-configuration-options","title":"Planned Global Configuration Options","text":"<p>These are ideas for future options that are not currently implemented, but could be if there is enough interest:</p> <ul> <li>PLANNED: Provide CLI arguments like <code>pytest-recording</code> (<code>request.config.getoption(\"--record-mode\") or \"none\"</code>) for one-time changes to configuration</li> <li>PLANNED: Consider filters to prevent secrets from being cached: <code>filter_headers=[['authorization', 'id'], ['authorization', 'cookies']]</code> (Although, you should be using a pre-commit hook and formatting the dict before passing to to the cache)</li> <li>TODO: Add tips from Jest on best practices \u2013 treat snapshots as code, etc.</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome pull requests! For your pull request to be accepted smoothly, we suggest that you first open a GitHub issue to discuss your idea. For resources on getting started with the code base, see the below documentation:</p> <ul> <li>DEVELOPER_GUIDE</li> <li>STYLE_GUIDE</li> </ul>"},{"location":"#code-of-conduct","title":"Code of Conduct","text":"<p>We follow the Contributor Covenant Code of Conduct.</p>"},{"location":"#open-source-status","title":"Open Source Status","text":"<p>We try to reasonably meet most aspects of the \u201cOpenSSF scorecard\u201d from Open Source Insights</p>"},{"location":"#responsible-disclosure","title":"Responsible Disclosure","text":"<p>If you have any security issue to report, please contact the project maintainers privately. You can reach us at dev.act.kyle@gmail.com.</p>"},{"location":"#license","title":"License","text":"<p>LICENSE</p>"},{"location":"docs/Advanced_Documentation/","title":"Docs","text":"<p>Developer documentation</p>"},{"location":"docs/CHANGELOG/","title":"CHANGELOG","text":""},{"location":"docs/CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"docs/CHANGELOG/#fix","title":"Fix","text":"<ul> <li>remove StrEnum and improve RichAssertion on dict</li> <li>serialize pydantic BaseModels</li> <li>lower floor for pydantic version</li> </ul>"},{"location":"docs/CHANGELOG/#refactor","title":"Refactor","text":"<ul> <li>run pre-commit</li> <li>copier update</li> <li>apply pyupgrade</li> </ul>"},{"location":"docs/CHANGELOG/#306-2022-10-19","title":"3.0.6 (2022-10-19)","text":""},{"location":"docs/CHANGELOG/#fix_1","title":"Fix","text":"<ul> <li>use Python 3.8.4 in CI</li> </ul>"},{"location":"docs/CHANGELOG/#305-2022-10-18","title":"3.0.5 (2022-10-18)","text":""},{"location":"docs/CHANGELOG/#fix_2","title":"Fix","text":"<ul> <li>remove dump of raw data in error message</li> <li>serialize bytes by passing to str</li> <li>serialize datetime by default</li> </ul>"},{"location":"docs/CHANGELOG/#refactor_1","title":"Refactor","text":"<ul> <li>reduce serializer complexity</li> </ul>"},{"location":"docs/CHANGELOG/#304-2022-10-08","title":"3.0.4 (2022-10-08)","text":""},{"location":"docs/CHANGELOG/#fix_3","title":"Fix","text":"<ul> <li>serialize all classes</li> </ul>"},{"location":"docs/CHANGELOG/#303-2022-10-06","title":"3.0.3 (2022-10-06)","text":""},{"location":"docs/CHANGELOG/#fix_4","title":"Fix","text":"<ul> <li>support arbitrary class serialization</li> <li>escape slashes in filepaths</li> </ul>"},{"location":"docs/CHANGELOG/#302-2022-10-04","title":"3.0.2 (2022-10-04)","text":""},{"location":"docs/CHANGELOG/#fix_5","title":"Fix","text":"<ul> <li>write metadata on first pass and autouse custom config</li> <li>pin maximum importlib-metadata for poetry publish</li> </ul>"},{"location":"docs/CHANGELOG/#301-2022-10-04","title":"3.0.1 (2022-10-04)","text":""},{"location":"docs/CHANGELOG/#fix_6","title":"Fix","text":"<ul> <li>register the AssertConfig when set</li> <li>only set override fixture once (in client tests)</li> <li>move generic memory serializer after type lookup</li> <li>support in-memory assertion checking</li> <li>handle serializing MagicMock</li> </ul>"},{"location":"docs/CHANGELOG/#refactor_2","title":"Refactor","text":"<ul> <li>type ignore comment removal</li> <li>switch to BaseModel and Protocol</li> </ul>"},{"location":"docs/CHANGELOG/#300-2022-09-25","title":"3.0.0 (2022-09-25)","text":""},{"location":"docs/CHANGELOG/#feat","title":"Feat","text":"<ul> <li>add missing Wild.recur</li> <li>initiaiize Wild class and rename KeyRule to AssertRule</li> <li>add serializer to store only relative paths</li> <li>begin supporting string-based KeyRules!</li> <li>even better error messages</li> <li>start switch from dictdiffer to deepdiff</li> <li>start migration of attrs to pydantic</li> <li>migrate from pendulum to arrow</li> </ul>"},{"location":"docs/CHANGELOG/#fix_7","title":"Fix","text":"<ul> <li>replace punq with dictionary config for failing tests</li> <li>remove casts because they break the tests</li> <li>cast to Interface and not Protocol</li> <li>resolve list regex matching rules</li> <li>determine how to match regex for nested paths</li> <li>continue to update tests for change in pattern syntax</li> <li>start removing the Wildcards and legacy KeyRules</li> </ul>"},{"location":"docs/CHANGELOG/#refactor_3","title":"Refactor","text":"<ul> <li>considered ssort, but blocked by https://github.com/bwhmather/ssort/issues/70</li> <li>last fix to restore mypy passing</li> <li>correct type ignore comments</li> <li>additional changes to pass type checks</li> <li>better support mypy</li> <li>add pydantic validators to custom types</li> <li>by default nest the caches by test file</li> <li>use suppress and remove loguru from pkg</li> </ul>"},{"location":"docs/CHANGELOG/#200-2022-05-01","title":"2.0.0 (2022-05-01)","text":""},{"location":"docs/CHANGELOG/#feat_1","title":"Feat","text":"<ul> <li>make numpy, pandas, and pydantic optionally serialize</li> <li>replace preconvert with custom registration logic</li> <li>#3: implement always_write</li> <li>initialize configurable list of converters</li> <li>implement DictDifferValidator</li> <li>implement LocalJSONCacheStore</li> <li>initialize new customization features</li> </ul>"},{"location":"docs/CHANGELOG/#fix_8","title":"Fix","text":"<ul> <li>on first write use test_data for comparison</li> <li>order of flow for parsing diff result</li> <li>handling s3 serialization and remove returns</li> <li>s3 serialization needs to catch all objects</li> <li>try to fix s3 serialization</li> <li>remove type checking entirely for str</li> <li>str can\u2019t be type-checked</li> <li>resolve local test failures after initial refactor</li> <li>commitizen changed Cerberus dependency version</li> </ul>"},{"location":"docs/CHANGELOG/#refactor_4","title":"Refactor","text":"<ul> <li>always override the converter</li> <li>support an optional Path</li> <li>replace TEST_DATA_TYPE with Any</li> <li>switch to preconvert internally</li> <li>encapsulate JSON logic</li> <li>combine into single CacheStore representation</li> <li>separate functional logic from state for DictDiff</li> <li>remove optional validator argument</li> <li>decouple AssertConfig from plugin</li> </ul>"},{"location":"docs/CHANGELOG/#135-2022-03-03","title":"1.3.5 (2022-03-03)","text":""},{"location":"docs/CHANGELOG/#fix_9","title":"Fix","text":"<ul> <li>another attempt at fixing edge case for unknown class</li> </ul>"},{"location":"docs/CHANGELOG/#134-2022-03-03","title":"1.3.4 (2022-03-03)","text":""},{"location":"docs/CHANGELOG/#fix_10","title":"Fix","text":"<ul> <li>class is only in the type string</li> </ul>"},{"location":"docs/CHANGELOG/#133-2022-03-03","title":"1.3.3 (2022-03-03)","text":""},{"location":"docs/CHANGELOG/#fix_11","title":"Fix","text":"<ul> <li>handle edge cases with serializing classes</li> </ul>"},{"location":"docs/CHANGELOG/#132-2022-03-01","title":"1.3.2 (2022-03-01)","text":""},{"location":"docs/CHANGELOG/#fix_12","title":"Fix","text":"<ul> <li>debug recursive serialization for diffing</li> <li>handle one-level of recursion in lists</li> </ul>"},{"location":"docs/CHANGELOG/#131-2022-02-27","title":"1.3.1 (2022-02-27)","text":""},{"location":"docs/CHANGELOG/#fix_13","title":"Fix","text":"<ul> <li>correct type validation of AssertConfig ser_rules</li> </ul>"},{"location":"docs/CHANGELOG/#130-2022-02-27","title":"1.3.0 (2022-02-27)","text":""},{"location":"docs/CHANGELOG/#feat_2","title":"Feat","text":"<ul> <li>improve configurability with AssertConfig</li> <li>introduce internally configurable punq</li> </ul>"},{"location":"docs/CHANGELOG/#121-2022-02-27","title":"1.2.1 (2022-02-27)","text":""},{"location":"docs/CHANGELOG/#fix_14","title":"Fix","text":"<ul> <li>support Paths</li> </ul>"},{"location":"docs/CHANGELOG/#120-2022-02-27","title":"1.2.0 (2022-02-27)","text":""},{"location":"docs/CHANGELOG/#feat_3","title":"Feat","text":"<ul> <li>WIP serializer to support functions</li> <li>copier update. Add Github Actions</li> </ul>"},{"location":"docs/CHANGELOG/#fix_15","title":"Fix","text":"<ul> <li>implement serializer before diffing</li> <li>failing tests and run doit</li> </ul>"},{"location":"docs/CHANGELOG/#refactor_5","title":"Refactor","text":"<ul> <li>use next generation attrs syntax</li> </ul>"},{"location":"docs/CHANGELOG/#111-2022-02-18","title":"1.1.1 (2022-02-18)","text":""},{"location":"docs/CHANGELOG/#fix_16","title":"Fix","text":"<ul> <li>show the changelog on PyPi</li> </ul>"},{"location":"docs/CHANGELOG/#refactor_6","title":"Refactor","text":"<ul> <li>drop 2021 prefix on tags</li> </ul>"},{"location":"docs/CHANGELOG/#110-2022-02-18","title":"1.1.0 (2022-02-18)","text":""},{"location":"docs/CHANGELOG/#feat_4","title":"Feat","text":"<ul> <li>new assert_against_dict for in-memory comparison</li> <li>add support for comparing date-times</li> </ul>"},{"location":"docs/CHANGELOG/#fix_17","title":"Fix","text":"<ul> <li>argument order issues in main</li> <li>datetime comparison logic</li> </ul>"},{"location":"docs/CHANGELOG/#refactor_7","title":"Refactor","text":"<ul> <li>use beartype\u2019s typing imports</li> </ul>"},{"location":"docs/CHANGELOG/#100-2021-11-02","title":"1.0.0 (2021-11-02)","text":""},{"location":"docs/CHANGELOG/#feat_5","title":"Feat","text":"<ul> <li>improve serialization</li> </ul>"},{"location":"docs/CHANGELOG/#fix_18","title":"Fix","text":"<ul> <li>correctly implement an optional fixture</li> <li>make config fixture optional</li> </ul>"},{"location":"docs/CHANGELOG/#100rc0-2021-11-02","title":"1.0.0rc0 (2021-11-02)","text":""},{"location":"docs/CHANGELOG/#feat_6","title":"Feat","text":"<ul> <li>support comparison of lists</li> <li>always write metadata as a list</li> <li>customizable cache directory</li> <li>support lists of dictionaries</li> <li>replace asterisk string with Wildcard enum</li> <li>support UUID in check_type</li> </ul>"},{"location":"docs/CHANGELOG/#fix_19","title":"Fix","text":"<ul> <li>support dictionary keys with dots</li> <li>add CNAME for custom subdomain</li> <li>add missing check_imports file</li> </ul>"},{"location":"docs/CHANGELOG/#refactor_8","title":"Refactor","text":"<ul> <li>code cleanup &amp; documentation updates</li> <li>simplify merge_metadata logic</li> <li>serialize the func_args metadata recursively</li> <li>improve code quality of _raw_diff</li> </ul>"},{"location":"docs/CHANGELOG/#010-2021-10-31","title":"0.1.0 (2021-10-31)","text":""},{"location":"docs/CHANGELOG/#feat_7","title":"Feat","text":"<ul> <li>implement key rules</li> <li>implement dictdiffer wrapper</li> <li>initialize decoupled differ and error message (WIP)</li> <li>use dictdiffer for quick fix for assertion messages</li> <li>resolve cache file name based on pytest metadata</li> <li>initial attempt at pytest plugin</li> <li>initialize package code and tests</li> <li>start with Readme (RDD)</li> <li>initialized project with copier</li> </ul>"},{"location":"docs/CHANGELOG/#fix_20","title":"Fix","text":"<ul> <li>add tests and verify correctness of KeyRule</li> <li>use full name instead of custom indexing for cache</li> <li>use 2-spaces on JSON for pre-commit</li> <li>reduce stored metadata and check args</li> <li>re-run \u201cpoetry install\u201d after entrypoint changes</li> </ul>"},{"location":"docs/CHANGELOG/#refactor_9","title":"Refactor","text":"<ul> <li>rename checks to main</li> <li>rename check_assert to assert_against_cache &amp; update README</li> <li>drop transformer and match_precision</li> <li>update notes and implementation plans</li> </ul>"},{"location":"docs/CODE_TAG_SUMMARY/","title":"Task Summary","text":"<p>Auto-Generated by <code>calcipy</code></p> Type Comment Last Edit Source File TODO Please describe the purpose and high-level explanation of the changes \u2013&gt; 2022-12-05 .github/PULL_REQUEST_TEMPLATE.md:5 FIXME Needs to support mkdocs: https://github.com/executablebooks/mdformat/issues/317 2022-09-17 .pre-commit-config.yaml:49 PLANNED Provide CLI arguments like <code>pytest-recording</code> (<code>request.config.getoption(\"--record-mode\") or \"none\"</code>) for one-time changes to configuration 2021-11-02 docs/README.md:199 PLANNED Consider filters to prevent secrets from being cached: <code>filter_headers=[['authorization', 'id'], ['authorization', 'cookies']]</code> (Although, you should be using a pre-commit hook and formatting the dict before passing to to the cache) 2022-09-25 docs/README.md:200 TODO Add tips from Jest on best practices \u2013 treat snapshots as code, etc. 2022-09-25 docs/README.md:201 PLANNED Faster to LBYL or EAFP? 2022-09-22 pytest_cache_assert/_check_assert/serializer.py:110 FIXME Replace with programmatic imports? Maybe explicit imports to check backward compatibility of public API? 2022-02-18 scripts/check_imports.py:7 TODO Add tests for additional types: st.binary(), etc. 2022-03-07 tests/test_main.py:160 <p>Found code tags for FIXME (2), TODO (3), PLANNED (3)</p>"},{"location":"docs/DEVELOPER_GUIDE/","title":"Developer Notes","text":""},{"location":"docs/DEVELOPER_GUIDE/#local-development","title":"Local Development","text":"<pre><code>git clone https://github.com/kyleking/pytest_cache_assert.git\ncd pytest_cache_assert\npoetry install\n\n# See the available tasks\npoetry run doit list\n\n# Run the default task list (lint, auto-format, test coverage, etc.)\npoetry run doit --continue\n\n# Make code changes and run specific tasks as needed:\npoetry run doit run test\n</code></pre>"},{"location":"docs/DEVELOPER_GUIDE/#publishing","title":"Publishing","text":"<p>For testing, create an account on TestPyPi. Replace <code>...</code> with the API token generated on TestPyPi or PyPi respectively</p> <pre><code>poetry config repositories.testpypi https://test.pypi.org/legacy/\npoetry config pypi-token.testpypi ...\n\npoetry run doit run publish_test_pypi\n# If you didn't configure a token, you will need to provide your username and password to publish\n</code></pre> <p>To publish to the real PyPi</p> <pre><code>poetry config pypi-token.pypi ...\npoetry run doit run publish\n\n# For a full release, triple check the default tasks, increment the version, rebuild documentation (twice), and publish!\npoetry run doit run --continue\npoetry run doit run cl_bump lock document deploy_docs publish\n\n# For pre-releases use cl_bump_pre\npoetry run doit run cl_bump_pre -p rc\npoetry run doit run lock document deploy_docs publish\n</code></pre>"},{"location":"docs/DEVELOPER_GUIDE/#current-status","title":"Current Status","text":"File Statements Missing Excluded Coverage <code>pytest_cache_assert/__init__.py</code> 9 0 0 100.0% <code>pytest_cache_assert/_check_assert/__init__.py</code> 0 0 0 100.0% <code>pytest_cache_assert/_check_assert/assert_config.py</code> 24 0 0 100.0% <code>pytest_cache_assert/_check_assert/assert_rules.py</code> 86 8 0 90.7% <code>pytest_cache_assert/_check_assert/cache_store.py</code> 41 4 0 90.2% <code>pytest_cache_assert/_check_assert/caching.py</code> 36 0 0 100.0% <code>pytest_cache_assert/_check_assert/config.py</code> 27 0 0 100.0% <code>pytest_cache_assert/_check_assert/constants.py</code> 17 0 0 100.0% <code>pytest_cache_assert/_check_assert/converter.py</code> 6 0 0 100.0% <code>pytest_cache_assert/_check_assert/differ.py</code> 41 2 0 95.1% <code>pytest_cache_assert/_check_assert/error_message.py</code> 21 0 0 100.0% <code>pytest_cache_assert/_check_assert/serializer.py</code> 121 7 0 94.2% <code>pytest_cache_assert/_check_assert/validator.py</code> 20 1 0 95.0% <code>pytest_cache_assert/main.py</code> 27 0 0 100.0% <code>pytest_cache_assert/plugin.py</code> 45 2 0 95.6% Totals 521 24 0 95.4% <p>Generated on: 2023-01-09</p>"},{"location":"docs/STYLE_GUIDE/","title":"Personal Style Guides","text":""},{"location":"docs/STYLE_GUIDE/#git","title":"Git","text":"<p>We use Commitizen to manage both an auto-generated Changelog and incrementing the release version following semver. For both of these automated outputs to work well, please follow the Conventional Commits style, which is described in more detail below.</p>"},{"location":"docs/STYLE_GUIDE/#commitizen-types-and-scopes","title":"Commitizen Types and Scopes","text":"<p><code>type(scope): description</code></p> <ul> <li>Types<ul> <li>fix: A bug fix</li> <li>feat: A new feature</li> <li>docs: Documentation-only changes (code comments, separate docs)</li> <li>style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons)</li> <li>perf: A code change that improves performance</li> <li>refactor: A change to production code that is not a fix, feat, or perf</li> <li>test: Adding missing or correcting existing tests</li> <li>build: Changes that affect the build system or external dependencies</li> <li>ci: Changes to our CI configuration files and scripts</li> <li>A <code>!</code> can be used to indicate a breaking change (<code>refactor!: drop support for Node 6</code>)</li> <li>SemVer Rules<ul> <li>Based on commit type, the version will be auto-incremented: <code>fix : PATCH // feat : MINOR // BREAKING CHANGE : MAJOR</code></li> </ul> </li> </ul> </li> <li>Scopes<ul> <li>A Class, File name, Issue Number, other appropriate noun. As examples: <code>build(poetry): bump requests to v3</code> or <code>style(#32): add missing type annotations</code></li> </ul> </li> <li>Tips<ul> <li>What if a commit fits multiple types?<ul> <li>Go back and make multiple commits whenever possible. Part of the benefit of Conventional Commits is the focus on more organized and intentional changes</li> </ul> </li> <li>Use <code>git rebase -i</code> to fix commit names prior to merging if incorrect types/scopes are used</li> </ul> </li> </ul>"},{"location":"docs/STYLE_GUIDE/#git-description-guidelines","title":"Git Description Guidelines","text":"<ul> <li>Commit message guidelines<ul> <li>Full sentence with verb (lowercase) and concise description. Below are modified examples for Conventional Commits<ul> <li><code>fix(roles): bug in admin role permissions</code></li> <li><code>feat(ui): implement new button design</code></li> <li><code>build(pip): upgrade package to remove vulnerabilities</code></li> <li><code>refactor: file structure to improve code readability</code></li> <li><code>perf(cli): rewrite methods</code></li> <li><code>feat(api): endpoints to implement new customer dashboard</code></li> </ul> </li> </ul> </li> <li>How to write a good commit message<ul> <li>A diff will tell you what changed, but only the commit message can properly tell you why.</li> <li>Keep in mind: This has all been said before.</li> <li>From the seven rules of a great Git commit message:<ul> <li> <ol> <li>Try for 50 characters, but consider 72 the hard limit</li> </ol> </li> <li> <ol> <li>Use the body to explain what and why vs. how</li> </ol> </li> </ul> </li> </ul> </li> </ul>"},{"location":"docs/STYLE_GUIDE/#issue-labels-and-milestones","title":"Issue Labels and Milestones","text":"<p>Personal Guide</p> <ul> <li>For Issue Labels, see labels.yml</li> <li>Milestones<ul> <li>Current Tasks: main milestone (name could change based on a specific project, sprint, or month)</li> <li>Next Tasks</li> <li>Blue Sky</li> </ul> </li> </ul> Research <ul> <li>[Sane Github Labels](https://medium.com/@dave_lunny/sane-github-labels-c5d2e6004b63) and see [sensible-github-labels](https://github.com/Relequestual/sensible-github-labels) for full descriptions of each</li> <ul> <li>\u201cit is much more helpful to see the status and type of all issues at a glance.\u201d</li> <li>One of each:</li> <ul> <li>Status: \u2026</li> <ul><li>Abandoned, Accepted, Available, Blocked, Completed, In Progress, On Hold, Pending, Review Needed, Revision Needed</li></ul> <li>Type: \u2026</li> <ul><li>Bug, Maintenance, Question, Enhancement</li></ul> <li>Priority: \u2026</li> <ul><li>Critical, High, Medium, Low</li></ul> </ul> </ul> <li>[Britecharts](https://britecharts.github.io/britecharts/github-labels.html)</li> <ul> <li>Status: \u2026</li> <ul> <li>On Review \u2013 Request that we are pondering if including or not</li> <li>Needs Reproducing \u2013 For bugs that need to be reproduced in order to get fixed</li> <li>Needs Design \u2013 Feature that needs a design</li> <li>Ready to Go \u2013 Issue that has been defined and is ready to get started with</li> <li>In Progress \u2013 Issue that is being worked on right now.</li> <li>Completed \u2013 Finished feature or fix</li> </ul> <li>Type: \u2026</li> <ul> <li>Bug \u2013 An unexpected problem or unintended behavior</li> <li>Feature \u2013 A new feature request</li> <li>Maintenance \u2013 A regular maintenance chore or task, including refactors, build system, CI, performance improvements</li> <li>Documentation \u2013 A documentation improvement task</li> <li>Question \u2013 An issue or PR that needs more information or a user question</li> </ul> <li>Not Included</li> <ul> <li>Priority: They would add complexity and overhead due to the discussions, but could help with the roadmap</li> <li>Technology Labels: It can create too much overhead, as properly tag with technologies all the issues could be time consuming</li> </ul> </ul> </ul> <li>[Ian Bicking Blog](https://www.ianbicking.org/blog/2014/03/use-github-issues-to-organize-a-project.html)</li> <ul> <li>Milestone Overview</li> <ul> <li>What are we doing right now?</li> <li>What aren\u2019t we doing right now?</li> <ul> <li>2a. Stuff we\u2019ll probably do soon</li> <li>2b. Stuff we probably won\u2019t do soon</li> </ul> <li>What aren\u2019t we sure about?</li> </ul> <li>Milestone Descriptions</li> <ul> <li>Stuff we are doing right now: this is the \u201cmain\u201d milestone. We give it a name (like Alpha 2 or Strawberry Rhubarb Pie) and we write down what we are trying to accomplish with the milestone. We create a new milestone when we are ready for the next iteration.</li> <li>Stuff we\u2019ll probably do soon: this is a standing \u201c**Next Tasks**\u201d milestone. We never change or rename this milestone.</li> <ul><li>We use a permanent \u201cNext Tasks\u201d milestone (as opposed to renaming it to \u201cAlpha 3\u201d or actual-next-iteration milestone) because we don\u2019t want to presume or default to including something in the real next iteration. When we\u2019re ready to start planning the next iteration we\u2019ll create a new milestone, and only deliberately move things into that milestone.</li></ul> <li>Stuff we probably won\u2019t do soon: this is a standing \u201c**Blue Sky**\u201d milestone. We refer to these tickets and sometimes look through them, but they are easy to ignore, somewhat intentionally ignored.</li> <li>What aren\u2019t we sure about?: issues with no milestone.</li> </ul> <li>Label: \u201cNeeds Discussion\u201d - (addressed in a triage meeting) - use liberally for either big or small tickets</li> <li>\u201cIt\u2019s better to give people more power: it\u2019s actually helpful if people can overreach because it is an opportunity to establish where the limits really are and what purpose those limits have\u201d</li> </ul>"},{"location":"docs/STYLE_GUIDE/#external-links","title":"External Links","text":"<p>TODO: Revisit</p> <ul> <li>Git: The Simple Guide</li> <li>Commit Messages and why use the present tense</li> <li>Github\u2019s Advice on Github</li> <li>Most Comprehensive Guide</li> <li>Git Pro Book (free)<ul> <li>Bash Tab-Completion Snippet</li> </ul> </li> </ul>"},{"location":"docs/STYLE_GUIDE/#python","title":"Python","text":"<p>TODO: Revisit</p> <ul> <li>Python Style Guides<ul> <li>https://gist.github.com/sloria/7001839</li> <li>http://www.nilunder.com/blog/2013/08/03/pythonic-sensibilities/</li> <li>https://innoq.github.io/cards42org_en/</li> <li>https://docs.openstack.org/hacking/latest/user/hacking.html#styleguide</li> <li>https://www.python.org/doc/humor/</li> <li>https://docs.python-guide.org/writing/reading/</li> <li>https://realpython.com/python-refactoring/</li> </ul> </li> </ul>"},{"location":"docs/STYLE_GUIDE/#adrs","title":"ADRs","text":"<p>TODO: Revisit</p> <ul> <li>Examples<ul> <li>https://github.com/pawamoy/mkdocstrings/issues/28</li> </ul> </li> </ul> <p>&lt;\u2013 Links \u2013&gt;</p>"},{"location":"modules/pytest_cache_assert/_code_diagrams/","title":"Code Diagrams","text":"<p>Auto-generated with <code>pylint-pyreverse</code></p>"},{"location":"modules/pytest_cache_assert/_code_diagrams/#packages","title":"Packages","text":"<p>Full Size</p>"},{"location":"modules/pytest_cache_assert/_code_diagrams/#classes","title":"Classes","text":"<p>Full Size</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pytest_cache_assert     * _check_assert         * assert_config         * assert_rules         * cache_store         * caching         * config         * constants         * converter         * differ         * error_message         * serializer         * validator     * main     * plugin</li> </ul>"},{"location":"reference/pytest_cache_assert/","title":"pytest_cache_assert","text":"<p>pytest_cache_assert.</p>"},{"location":"reference/pytest_cache_assert/#pytest_cache_assert-attributes","title":"Attributes","text":""},{"location":"reference/pytest_cache_assert/#pytest_cache_assert-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/#pytest_cache_assert-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/main/","title":"main","text":"<p>Assertion checks for unit tests.</p> <p>FYI: Should not require any pytest functionality</p>"},{"location":"reference/pytest_cache_assert/main/#pytest_cache_assert.main-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/main/#pytest_cache_assert.main.assert_against_cache","title":"assert_against_cache","text":"<pre><code>assert_against_cache(test_data, *, path_cache_dir, cache_name, assert_rules=None, metadata=None, always_write=None)\n</code></pre> <p>Core logic for pytest_cache_assert to handle caching and assertion-checking.</p> PARAMETER DESCRIPTION <code>test_data</code> <p>dictionary or list to test (could be from cache)</p> <p> TYPE: <code>Any</code> </p> <code>path_cache_dir</code> <p>location of the cache directory</p> <p> TYPE: <code>Path</code> </p> <code>cache_name</code> <p>relative string path from the test_dir to the JSON cache file</p> <p> TYPE: <code>str</code> </p> <code>assert_rules</code> <p>dictionary of AssertRules to apply when selectively ignoring differences</p> <p> TYPE: <code>Optional[List[AssertRule]]</code> DEFAULT: <code>None</code> </p> <code>metadata</code> <p>metadata dictionary to store in the cache file</p> <p> TYPE: <code>Optional[Dict]</code> DEFAULT: <code>None</code> </p> <code>always_write</code> <p>if True, always write the changes</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> Source code in <code>pytest_cache_assert/main.py</code> <pre><code>@beartype\ndef assert_against_cache(\ntest_data: Any,\n*,\npath_cache_dir: Path,\ncache_name: str,\nassert_rules: Optional[List[AssertRule]] = None,\nmetadata: Optional[Dict] = None,  # type: ignore[type-arg]\nalways_write: Optional[bool] = None,\n) -&gt; None:\n\"\"\"Core logic for pytest_cache_assert to handle caching and assertion-checking.\n    Args:\n        test_data: dictionary or list to test (could be from cache)\n        path_cache_dir: location of the cache directory\n        cache_name: relative string path from the test_dir to the JSON cache file\n        assert_rules: dictionary of AssertRules to apply when selectively ignoring differences\n        metadata: metadata dictionary to store in the cache file\n        always_write: if True, always write the changes\n    \"\"\"\nconfig = retrieve(CacheAssertContainerKeys.CONFIG)\ncache_store = config.cache_store\npath_cache_file = path_cache_dir / cache_name\ncache_store.initialize(path_cache_dir, config.converters)\ntest_data = cache_store.serialize(test_data)\n# Function argument overrides global\naw = config.always_write if always_write is None else always_write\ntry:\ncached_data = cache_store.read_cached_data(path_cache_file)\nexcept NoCacheError:\ncached_data = test_data\ncache_store.write(path_cache_file, metadata=metadata, test_data=test_data, always_write=aw)\nvalidator = config.validator\nvalidator.assertion(\ncached_data=cached_data, test_data=test_data, assert_rules=assert_rules or [],\npath_cache_file=path_cache_file,\n)\n</code></pre>"},{"location":"reference/pytest_cache_assert/main/#pytest_cache_assert.main.assert_against_dict","title":"assert_against_dict","text":"<pre><code>assert_against_dict(old_dict, new_dict, assert_rules=None)\n</code></pre> <p>Utilize custom DictDiffer logic to compare in-memory dictionaries.</p> PARAMETER DESCRIPTION <code>old_dict</code> <p>old dictionary (typically cached one)</p> <p> TYPE: <code>Dict</code> </p> <code>new_dict</code> <p>new dictionary (typically test data)</p> <p> TYPE: <code>Dict</code> </p> <code>assert_rules</code> <p>dictionary of AssertRules to apply when selectively ignoring differences</p> <p> TYPE: <code>Optional[List[AssertRule]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pytest_cache_assert/main.py</code> <pre><code>@beartype\ndef assert_against_dict(\nold_dict: Dict,  # type: ignore[type-arg]\nnew_dict: Dict,  # type: ignore[type-arg]\nassert_rules: Optional[List[AssertRule]] = None,\n) -&gt; None:\n\"\"\"Utilize custom DictDiffer logic to compare in-memory dictionaries.\n    Args:\n        old_dict: old dictionary (typically cached one)\n        new_dict: new dictionary (typically test data)\n        assert_rules: dictionary of AssertRules to apply when selectively ignoring differences\n    \"\"\"\nconfig = retrieve(CacheAssertContainerKeys.CONFIG)\ncache_store = config.cache_store\ncache_store.initialize(None, config.converters)\nnew_dict = cache_store.serialize(new_dict)\nvalidator = config.validator\nvalidator.assertion(cached_data=old_dict, test_data=new_dict, assert_rules=assert_rules or [])\n</code></pre>"},{"location":"reference/pytest_cache_assert/plugin/","title":"plugin","text":"<p>Pytest Plugin.</p>"},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin.TestMetadata","title":"TestMetadata","text":"<p>         Bases: <code>BaseModel</code></p> <p>Test MetaData.</p> Source code in <code>pytest_cache_assert/plugin.py</code> <pre><code>class TestMetadata(BaseModel):\n\"\"\"Test MetaData.\"\"\"\ntest_file: str\ntest_name: str\nfunc_args: Union[Dict, Iterable]  # type: ignore[type-arg]\nclass Config:\narbitrary_types_allowed = True\nfrozen = True\n@classmethod\n@beartype\ndef from_pytest(cls, request: FixtureRequest, rel_test_file: Path) -&gt; TestMetadata:\n\"\"\"Resolve TestMetadata.\n        Args:\n            request: pytest fixture used to identify the test directory\n            rel_test_file: relative path to the test file\n        Returns:\n            TestMetadata: new TestMetadata\n        \"\"\"\ntest_name = (f'{request.cls.__name__}/' if request.cls else '') + request.node.originalname\ntest_params = [*inspect.signature(request.node.function).parameters.keys()]\nfunc_args = {key: value for key, value in request.node.funcargs.items() if key in test_params}\nreturn cls(test_file=rel_test_file.as_posix(), test_name=test_name, func_args=func_args)\n</code></pre>"},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin.TestMetadata-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin.TestMetadata.from_pytest","title":"from_pytest  <code>classmethod</code>","text":"<pre><code>from_pytest(request, rel_test_file)\n</code></pre> <p>Resolve TestMetadata.</p> PARAMETER DESCRIPTION <code>request</code> <p>pytest fixture used to identify the test directory</p> <p> TYPE: <code>FixtureRequest</code> </p> <code>rel_test_file</code> <p>relative path to the test file</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>TestMetadata</code> <p>new TestMetadata</p> <p> TYPE: <code>TestMetadata</code> </p> Source code in <code>pytest_cache_assert/plugin.py</code> <pre><code>@classmethod\n@beartype\ndef from_pytest(cls, request: FixtureRequest, rel_test_file: Path) -&gt; TestMetadata:\n\"\"\"Resolve TestMetadata.\n    Args:\n        request: pytest fixture used to identify the test directory\n        rel_test_file: relative path to the test file\n    Returns:\n        TestMetadata: new TestMetadata\n    \"\"\"\ntest_name = (f'{request.cls.__name__}/' if request.cls else '') + request.node.originalname\ntest_params = [*inspect.signature(request.node.function).parameters.keys()]\nfunc_args = {key: value for key, value in request.node.funcargs.items() if key in test_params}\nreturn cls(test_file=rel_test_file.as_posix(), test_name=test_name, func_args=func_args)\n</code></pre>"},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/plugin/#pytest_cache_assert.plugin.assert_against_cache","title":"assert_against_cache","text":"<pre><code>assert_against_cache(request, cache_assert_config=None)\n</code></pre> <p>Return main.assert_against_cache with pytest-specific arguments already specified.</p> PARAMETER DESCRIPTION <code>request</code> <p>pytest fixture used to identify the test directory</p> <p> TYPE: <code>FixtureRequest</code> </p> <code>cache_assert_config</code> <p>pytest fixture that returns AssertConfig for user configuration</p> <p> TYPE: <code>Optional[AssertConfig]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Any], None]</code> <p>Callable[[Any], None]: <code>main.assert_against_cache()</code> with test_dir already specified</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>if the test directory cannot be determined</p> Source code in <code>pytest_cache_assert/plugin.py</code> <pre><code>@pytest.fixture()\n@beartype\ndef assert_against_cache(\nrequest: FixtureRequest,\ncache_assert_config: Optional[AssertConfig] = None,\n) -&gt; Callable[[Any], None]:\n\"\"\"Return main.assert_against_cache with pytest-specific arguments already specified.\n    Args:\n        request: pytest fixture used to identify the test directory\n        cache_assert_config: pytest fixture that returns AssertConfig for user configuration\n    Returns:\n        Callable[[Any], None]: `main.assert_against_cache()` with test_dir already specified\n    Raises:\n        RuntimeError: if the test directory cannot be determined\n    \"\"\"\nif cache_assert_config:\nregister(CacheAssertContainerKeys.CONFIG, cache_assert_config)\nassert_config = retrieve(CacheAssertContainerKeys.CONFIG)\ntest_dir = None\nfor sub_dir in ['tests', 'test']:\ntest_dir = request.config.rootpath / sub_dir\nif test_dir.is_dir():\nbreak\nelse:\nraise RuntimeError(f'Could not locate a \"tests/\" directory in {test_dir}')\n# Read user settings\npath_cache_dir = test_dir / assert_config.cache_dir_rel_path\n# Calculate keyword arguments\nrel_test_file = Path(request.node.fspath).relative_to(test_dir)\n# Escape slashes from the pytest node name\ntest_name = _RE_UNSAFE_CHAR.sub('-', request.node.name)\ncache_name = (rel_test_file.parent / rel_test_file.stem / f'{test_name}.json').as_posix()  # noqa: ECE001\nmetadata = TestMetadata.from_pytest(request=request, rel_test_file=rel_test_file).dict()\n# FYI: The partial function keyword arguments can be overridden when called\nreturn partial(main.assert_against_cache, path_cache_dir=path_cache_dir, cache_name=cache_name, metadata=metadata)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/","title":"_check_assert","text":"<p>Private package for pytest_check_assert.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/","title":"assert_config","text":"<p>Pytest Cache Assert Configuration Object.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config-attributes","title":"Attributes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig","title":"AssertConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>User configuration data structure.</p> Source code in <code>pytest_cache_assert/_check_assert/assert_config.py</code> <pre><code>class AssertConfig(BaseModel):\n\"\"\"User configuration data structure.\"\"\"\nalways_write: bool = False\n\"\"\"Always write to the cached file so that diffs can be examined in the user's VCS.\"\"\"\ncache_dir_rel_path: str = DEF_CACHE_DIR_NAME\n\"\"\"String relative directory from `tests/` where default resolves to `tests/assert-cache/`.\"\"\"\ncache_store: CacheStoreType = Field(default_factory=LocalJSONCacheStore)\n\"\"\"Configurable class for managing the cache representation. Default is local JSON.\n    Override the default `cache_store` to have a custom cache format and serialization\n    \"\"\"\nconverters: List[Converter] = Field(default_factory=list)\n\"\"\"Extend cache_store with custom functions for serializing novel types.\n    Example: `[Converter(types=[pd.DataFrame], func=panda_to_json)]` for\n    ```py\n    def panda_to_json(df: pd.DataFrame) -&gt; List[Dict]:\n        return json.loads(df.to_json(orient='records'))\n    ```\n    Useful for serializing data form pandas or other types that are unknown to the generic converters\n    \"\"\"\nvalidator: ValidatorType = Field(default_factory=DictDiffValidator)\n\"\"\"Custom validator for identifying and summarizing the deviations from the cache.\"\"\"\nclass Config:\narbitrary_types_allowed = True\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig-attributes","title":"Attributes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig.always_write","title":"always_write  <code>class-attribute</code>","text":"<pre><code>always_write: bool = False\n</code></pre> <p>Always write to the cached file so that diffs can be examined in the user\u2019s VCS.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig.cache_dir_rel_path","title":"cache_dir_rel_path  <code>class-attribute</code>","text":"<pre><code>cache_dir_rel_path: str = DEF_CACHE_DIR_NAME\n</code></pre> <p>String relative directory from <code>tests/</code> where default resolves to <code>tests/assert-cache/</code>.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig.cache_store","title":"cache_store  <code>class-attribute</code>","text":"<pre><code>cache_store: CacheStoreType = Field(default_factory=LocalJSONCacheStore)\n</code></pre> <p>Configurable class for managing the cache representation. Default is local JSON.</p> <p>Override the default <code>cache_store</code> to have a custom cache format and serialization</p>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig.converters","title":"converters  <code>class-attribute</code>","text":"<pre><code>converters: List[Converter] = Field(default_factory=list)\n</code></pre> <p>Extend cache_store with custom functions for serializing novel types.</p> <p>Example: <code>[Converter(types=[pd.DataFrame], func=panda_to_json)]</code> for</p> <pre><code>def panda_to_json(df: pd.DataFrame) -&gt; List[Dict]:\nreturn json.loads(df.to_json(orient='records'))\n</code></pre> <p>Useful for serializing data form pandas or other types that are unknown to the generic converters</p>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_config/#pytest_cache_assert._check_assert.assert_config.AssertConfig.validator","title":"validator  <code>class-attribute</code>","text":"<pre><code>validator: ValidatorType = Field(default_factory=DictDiffValidator)\n</code></pre> <p>Custom validator for identifying and summarizing the deviations from the cache.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/","title":"assert_rules","text":"<p>Key Rules.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules-attributes","title":"Attributes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.AssertRule","title":"AssertRule","text":"<p>         Bases: <code>BaseModel</code></p> <p>Key Rule.</p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>class AssertRule(BaseModel):\n\"\"\"Key Rule.\"\"\"\npattern: Union[str, Pattern]  # type: ignore[type-arg] # https://github.com/pydantic/pydantic/issues/2636\nfunc: Callable[[T_DIFF, T_DIFF], bool]\n@classmethod\ndef build_re(cls, pattern: List[str], func: Callable[[T_DIFF, T_DIFF], bool]) -&gt; 'AssertRule':\n\"\"\"Build a regex pattern from list.\"\"\"\nif not pattern:\nraise ValueError(\"Expected at least one item in 'pattern'\")\nif pattern[0].startswith('root['):\nraise ValueError(\"Exclude 'root' and brackets. This method builds it for you\")\npattern_re = f'root{_PAT_START}{_PAT_JOIN.join(pattern)}{_PAT_END}'\nreturn cls(pattern=re.compile(pattern_re), func=func)\ndef is_regex(self) -&gt; bool:\n\"\"\"Helper for checking if pattern is a regex or string.\"\"\"\nreturn not isinstance(self.pattern, str)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.AssertRule-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.AssertRule.build_re","title":"build_re  <code>classmethod</code>","text":"<pre><code>build_re(pattern, func)\n</code></pre> <p>Build a regex pattern from list.</p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>@classmethod\ndef build_re(cls, pattern: List[str], func: Callable[[T_DIFF, T_DIFF], bool]) -&gt; 'AssertRule':\n\"\"\"Build a regex pattern from list.\"\"\"\nif not pattern:\nraise ValueError(\"Expected at least one item in 'pattern'\")\nif pattern[0].startswith('root['):\nraise ValueError(\"Exclude 'root' and brackets. This method builds it for you\")\npattern_re = f'root{_PAT_START}{_PAT_JOIN.join(pattern)}{_PAT_END}'\nreturn cls(pattern=re.compile(pattern_re), func=func)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.AssertRule.is_regex","title":"is_regex","text":"<pre><code>is_regex()\n</code></pre> <p>Helper for checking if pattern is a regex or string.</p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>def is_regex(self) -&gt; bool:\n\"\"\"Helper for checking if pattern is a regex or string.\"\"\"\nreturn not isinstance(self.pattern, str)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Comparator","title":"Comparator","text":"<p>         Bases: <code>Enum</code></p> <p>Comparator Enum for AssertRules.</p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>class Comparator(Enum):  # noqa: H601\n\"\"\"Comparator Enum for AssertRules.\"\"\"\nLTE = 'new - old &lt;= value'\nGTE = 'new - old &gt;= value'\nWITHIN = 'abs(new - old) &lt;= value'\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild","title":"Wild","text":"<p>AssertRule Wildcard Patterns.</p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>class Wild:\n\"\"\"AssertRule Wildcard Patterns.\"\"\"\n@classmethod\ndef build(cls, inner_pattern: str, count: int = 1) -&gt; str:\n\"\"\"Specify a custom regular expression to match nested keys.\"\"\"\nif count &lt; 1:\nraise ValueError('Count must be at least one')\nreturn _PAT_JOIN.join([inner_pattern] * count)\n@classmethod\ndef index(cls, count: int = 1) -&gt; str:\n\"\"\"Return pattern that matches a specific number of nested lists in the cached data.\"\"\"\nreturn cls.build(r'\\d+', count)\n@classmethod\ndef keys(cls, count: int = 1) -&gt; str:\n\"\"\"Return pattern that matches a specific number of nested dictionary keys.\"\"\"\nreturn cls.build(r'[^\\]]+', count)\n@classmethod\ndef recur(cls, count: int = 1) -&gt; str:\n\"\"\"Return pattern that matches any level of nested dictionary keys or lists indices.\"\"\"\nreturn cls.build(r'.+', count)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild.build","title":"build  <code>classmethod</code>","text":"<pre><code>build(inner_pattern, count=1)\n</code></pre> <p>Specify a custom regular expression to match nested keys.</p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>@classmethod\ndef build(cls, inner_pattern: str, count: int = 1) -&gt; str:\n\"\"\"Specify a custom regular expression to match nested keys.\"\"\"\nif count &lt; 1:\nraise ValueError('Count must be at least one')\nreturn _PAT_JOIN.join([inner_pattern] * count)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild.index","title":"index  <code>classmethod</code>","text":"<pre><code>index(count=1)\n</code></pre> <p>Return pattern that matches a specific number of nested lists in the cached data.</p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>@classmethod\ndef index(cls, count: int = 1) -&gt; str:\n\"\"\"Return pattern that matches a specific number of nested lists in the cached data.\"\"\"\nreturn cls.build(r'\\d+', count)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild.keys","title":"keys  <code>classmethod</code>","text":"<pre><code>keys(count=1)\n</code></pre> <p>Return pattern that matches a specific number of nested dictionary keys.</p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>@classmethod\ndef keys(cls, count: int = 1) -&gt; str:\n\"\"\"Return pattern that matches a specific number of nested dictionary keys.\"\"\"\nreturn cls.build(r'[^\\]]+', count)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.Wild.recur","title":"recur  <code>classmethod</code>","text":"<pre><code>recur(count=1)\n</code></pre> <p>Return pattern that matches any level of nested dictionary keys or lists indices.</p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>@classmethod\ndef recur(cls, count: int = 1) -&gt; str:\n\"\"\"Return pattern that matches any level of nested dictionary keys or lists indices.\"\"\"\nreturn cls.build(r'.+', count)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.check_exact","title":"check_exact","text":"<pre><code>check_exact(old, new)\n</code></pre> <p>Check for value equality.</p> PARAMETER DESCRIPTION <code>old</code> <p>the old value</p> <p> TYPE: <code>T_DIFF</code> </p> <code>new</code> <p>the new value</p> <p> TYPE: <code>T_DIFF</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if both values are the exact same</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>@beartype\ndef check_exact(old: T_DIFF, new: T_DIFF) -&gt; bool:\n\"\"\"Check for value equality.\n    Args:\n        old: the old value\n        new: the new value\n    Returns:\n        bool: True if both values are the exact same\n    \"\"\"\nreturn old == new  # type: ignore[no-any-return]\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.check_suppress","title":"check_suppress","text":"<pre><code>check_suppress(old, new)\n</code></pre> <p>Return True to suppress differences.</p> PARAMETER DESCRIPTION <code>old</code> <p>the old value</p> <p> TYPE: <code>T_DIFF</code> </p> <code>new</code> <p>the new value</p> <p> TYPE: <code>T_DIFF</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Always True</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>@beartype\ndef check_suppress(old: T_DIFF, new: T_DIFF) -&gt; bool:\n\"\"\"Return True to suppress differences.\n    Args:\n        old: the old value\n        new: the new value\n    Returns:\n        bool: Always True\n    \"\"\"\nreturn True\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.check_type","title":"check_type","text":"<pre><code>check_type(old, new)\n</code></pre> <p>Check if both values are the exact same or same non-string type. Will attempt conversion from string.</p> PARAMETER DESCRIPTION <code>old</code> <p>the old value</p> <p> TYPE: <code>T_DIFF</code> </p> <code>new</code> <p>the new value</p> <p> TYPE: <code>T_DIFF</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if both values are the same kind</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>@beartype\ndef check_type(old: T_DIFF, new: T_DIFF) -&gt; bool:\n\"\"\"Check if both values are the exact same or same non-string type. Will attempt conversion from string.\n    Args:\n        old: the old value\n        new: the new value\n    Returns:\n        bool: True if both values are the same kind\n    \"\"\"\nif (\ncheck_exact(old=old, new=new)  # Catches if both null, etc.\nor (not isinstance(old, str) and isinstance(old, type(new)))\n):\nreturn True\nreturn _try_type_coercion(old=old, new=new)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.gen_check_date_proximity","title":"gen_check_date_proximity","text":"<pre><code>gen_check_date_proximity(time_delta, comparator=Comparator.WITHIN)\n</code></pre> <p>Generate a AssertRule check for date within the specified range.</p> PARAMETER DESCRIPTION <code>time_delta</code> <p>timedelta to use for checking that the new data is</p> <p> TYPE: <code>timedelta</code> </p> <code>comparator</code> <p>defaults to Comparator.WITHIN. Can make directional by setting LTE or GTE</p> <p> TYPE: <code>Comparator</code> DEFAULT: <code>Comparator.WITHIN</code> </p> RETURNS DESCRIPTION <code>Callable[[T_DIFF, T_DIFF], bool]</code> <p>Callable[[T_DIFF, T_DIFF], bool]: AssertRule check</p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>@beartype\ndef gen_check_date_proximity(\ntime_delta: timedelta, comparator: Comparator = Comparator.WITHIN,\n) -&gt; Callable[[T_DIFF, T_DIFF], bool]:\n\"\"\"Generate a AssertRule check for date within the specified range.\n    Args:\n        time_delta: timedelta to use for checking that the new data is\n        comparator: defaults to Comparator.WITHIN. Can make directional by setting LTE or GTE\n    Returns:\n        Callable[[T_DIFF, T_DIFF], bool]: AssertRule check\n    \"\"\"\nreturn partial(_check_date_proximity, time_delta=time_delta, comparator=comparator)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/assert_rules/#pytest_cache_assert._check_assert.assert_rules.gen_check_date_range","title":"gen_check_date_range","text":"<pre><code>gen_check_date_range(min_date=None, max_date=None)\n</code></pre> <p>Generate a AssertRule check for date within the specified range.</p> PARAMETER DESCRIPTION <code>min_date</code> <p>optional minimum datetime</p> <p> TYPE: <code>Optional[datetime]</code> DEFAULT: <code>None</code> </p> <code>max_date</code> <p>optional maximum datetime</p> <p> TYPE: <code>Optional[datetime]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[T_DIFF, T_DIFF], bool]</code> <p>Callable[[T_DIFF, T_DIFF], bool]: AssertRule check</p> Source code in <code>pytest_cache_assert/_check_assert/assert_rules.py</code> <pre><code>@beartype\ndef gen_check_date_range(\nmin_date: Optional[datetime] = None, max_date: Optional[datetime] = None,\n) -&gt; Callable[[T_DIFF, T_DIFF], bool]:\n\"\"\"Generate a AssertRule check for date within the specified range.\n    Args:\n        min_date: optional minimum datetime\n        max_date: optional maximum datetime\n    Returns:\n        Callable[[T_DIFF, T_DIFF], bool]: AssertRule check\n    \"\"\"\nreturn partial(_check_date_range, min_date=min_date, max_date=max_date)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/cache_store/","title":"cache_store","text":"<p>Representative class of the Cache Data Store.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/cache_store/#pytest_cache_assert._check_assert.cache_store-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/cache_store/#pytest_cache_assert._check_assert.cache_store.LocalJSONCacheStore","title":"LocalJSONCacheStore","text":"<p>Implementation of the CacheStore interface for a local JSON store.</p> Source code in <code>pytest_cache_assert/_check_assert/cache_store.py</code> <pre><code>class LocalJSONCacheStore:\n\"\"\"Implementation of the CacheStore interface for a local JSON store.\"\"\"\n@staticmethod\n@beartype\ndef initialize(path_cache_dir: Optional[Path], converters: Optional[List[Converter]] = None) -&gt; None:\nif converters:\nregister_user_converters(converters)\nif path_cache_dir:\ninit_cache(path_cache_dir)\n@staticmethod\n@beartype\ndef serialize(data: Any) -&gt; Any:\nreturn make_diffable(data=data)\n@staticmethod\n@beartype\ndef write(\npath_cache_file: Path,\n*,\nmetadata: Optional[Dict],  # type: ignore[type-arg]\ntest_data: Any,\nalways_write: bool = False,\n) -&gt; None:\nwrite_cache_data(\npath_cache_file=path_cache_file, metadata=metadata, test_data=test_data, always_write=always_write,\n)\n@staticmethod\n@beartype\ndef read_cached_data(path_cache_file: Path) -&gt; Any:\nreturn load_cached_data(path_cache_file)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/cache_store/#pytest_cache_assert._check_assert.cache_store-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/_check_assert/caching/","title":"caching","text":"<p>Utilities for managing the cache.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching-attributes","title":"Attributes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching.init_cache","title":"init_cache","text":"<pre><code>init_cache(path_cache_dir)\n</code></pre> <p>Ensure that the cache directory exists and add the README.</p> PARAMETER DESCRIPTION <code>path_cache_dir</code> <p>location of the cache directory</p> <p> TYPE: <code>Path</code> </p> Source code in <code>pytest_cache_assert/_check_assert/caching.py</code> <pre><code>@beartype\ndef init_cache(path_cache_dir: Path) -&gt; None:\n\"\"\"Ensure that the cache directory exists and add the README.\n    Args:\n        path_cache_dir: location of the cache directory\n    \"\"\"\npath_cache_dir.mkdir(exist_ok=True, parents=True)\n(path_cache_dir / 'README.md').write_text(CACHE_README_TEXT)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching.load_cached_data","title":"load_cached_data","text":"<pre><code>load_cached_data(path_cache_file)\n</code></pre> <p>Cache the specified data.</p> PARAMETER DESCRIPTION <code>path_cache_file</code> <p>location of the cache file to write</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>loaded data from cache file</p> <p> TYPE: <code>Any</code> </p> Source code in <code>pytest_cache_assert/_check_assert/caching.py</code> <pre><code>@beartype\ndef load_cached_data(path_cache_file: Path) -&gt; Any:\n\"\"\"Cache the specified data.\n    Args:\n        path_cache_file: location of the cache file to write\n    Returns:\n        Any: loaded data from cache file\n    \"\"\"\nif path_cache_file.is_file():\nreturn _read_full_cache(path_cache_file)[KEY_NAME_DATA]\nraise NoCacheError(f'No cache for: {path_cache_file}')\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/caching/#pytest_cache_assert._check_assert.caching.write_cache_data","title":"write_cache_data","text":"<pre><code>write_cache_data(path_cache_file, *, metadata, test_data, always_write=False)\n</code></pre> <p>Cache the specified data.</p> PARAMETER DESCRIPTION <code>path_cache_file</code> <p>location of the cache file to write</p> <p> TYPE: <code>Path</code> </p> <code>metadata</code> <p>optional dictionary for storing in the cache file</p> <p> TYPE: <code>Optional[Dict]</code> </p> <code>test_data</code> <p>arbitrary test data to store</p> <p> TYPE: <code>Any</code> </p> <code>always_write</code> <p>if True, overwrite the cached data</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>pytest_cache_assert/_check_assert/caching.py</code> <pre><code>@beartype\ndef write_cache_data(\npath_cache_file: Path,\n*,\nmetadata: Optional[Dict],  # type: ignore[type-arg]\ntest_data: Any,\nalways_write: bool = False,\n) -&gt; None:\n\"\"\"Cache the specified data.\n    Args:\n        path_cache_file: location of the cache file to write\n        metadata: optional dictionary for storing in the cache file\n        test_data: arbitrary test data to store\n        always_write: if True, overwrite the cached data\n    \"\"\"\nmetadata = make_diffable(metadata or {})\nmeta = [metadata or {}]\nif path_cache_file.is_file():\nold_cache_dict = _read_full_cache(path_cache_file)\nold_meta = old_cache_dict[KEY_NAME_META]\nmeta = _merge_metadata(meta[0], old_meta)\nif not always_write:  # Only change test_data if `always_write`\ntest_data = old_cache_dict[KEY_NAME_DATA]\ncache_dict = {KEY_NAME_META: meta, KEY_NAME_DATA: test_data}\npath_cache_file.parent.mkdir(exist_ok=True, parents=True)\npath_cache_file.write_text(pretty_dumps(cache_dict))\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/config/","title":"config","text":"<p>Configuration settings.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/config/#pytest_cache_assert._check_assert.config-attributes","title":"Attributes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/config/#pytest_cache_assert._check_assert.config.retrieve","title":"retrieve  <code>module-attribute</code>","text":"<pre><code>retrieve = _cache_assert_container.retrieve\n</code></pre> <p>Alias for exported function.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/config/#pytest_cache_assert._check_assert.config-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/config/#pytest_cache_assert._check_assert.config.CacheAssertContainerKeys","title":"CacheAssertContainerKeys","text":"<p>         Bases: <code>Enum</code></p> <p>Enum of keys used in <code>_cache_assert_container</code>.</p> Source code in <code>pytest_cache_assert/_check_assert/config.py</code> <pre><code>class CacheAssertContainerKeys(Enum):  # noqa: H601\n\"\"\"Enum of keys used in `_cache_assert_container`.\"\"\"\nCONFIG = '__config__'\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/constants/","title":"constants","text":"<p>Constants.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants-attributes","title":"Attributes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.CACHE_README_TEXT","title":"CACHE_README_TEXT  <code>module-attribute</code>","text":"<pre><code>CACHE_README_TEXT = '# Pytest Assert Cache\\n\\nThis folder is automatically generated by `pytest_cache_assert`.\\n\\nFiles can be regenerated by deleting and allowing `pytest_cache_assert` to recreate them when next running the test suite.\\n'\n</code></pre> <p>README content for the cache directory.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.DEF_CACHE_DIR_NAME","title":"DEF_CACHE_DIR_NAME  <code>module-attribute</code>","text":"<pre><code>DEF_CACHE_DIR_NAME = 'assert-cache'\n</code></pre> <p>Default <code>pytest_assert_cache</code> directory name.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.KEY_NAME_DATA","title":"KEY_NAME_DATA  <code>module-attribute</code>","text":"<pre><code>KEY_NAME_DATA = '_json'\n</code></pre> <p>Key for cached data.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.KEY_NAME_META","title":"KEY_NAME_META  <code>module-attribute</code>","text":"<pre><code>KEY_NAME_META = '_info'\n</code></pre> <p>Key for metadata.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.T_CONVERTER","title":"T_CONVERTER  <code>module-attribute</code>","text":"<pre><code>T_CONVERTER = Callable[[Any], T_SER]\n</code></pre> <p>Generic type for converters with a single argument.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.T_DIFF","title":"T_DIFF  <code>module-attribute</code>","text":"<pre><code>T_DIFF = Any\n</code></pre> <p>Possible Old or New difference type.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/constants/#pytest_cache_assert._check_assert.constants.T_SER","title":"T_SER  <code>module-attribute</code>","text":"<pre><code>T_SER = Optional[Union[str, int, float, bool, List, Dict]]\n</code></pre> <p>JSON-Serializable types.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/converter/","title":"converter","text":"<p>Pytest Cache Assert Configuration Object.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/converter/#pytest_cache_assert._check_assert.converter-attributes","title":"Attributes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/converter/#pytest_cache_assert._check_assert.converter-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/converter/#pytest_cache_assert._check_assert.converter.Converter","title":"Converter","text":"<p>         Bases: <code>BaseModel</code></p> <p>User-specific converters to extend the default <code>cache_store</code>.</p> Source code in <code>pytest_cache_assert/_check_assert/converter.py</code> <pre><code>class Converter(BaseModel, frozen=True):\n\"\"\"User-specific converters to extend the default `cache_store`.\"\"\"\ntypes: List[Any]\nfunc: T_CONVERTER\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/differ/","title":"differ","text":"<p>Dictionary Differ.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/differ/#pytest_cache_assert._check_assert.differ-attributes","title":"Attributes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/differ/#pytest_cache_assert._check_assert.differ-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/differ/#pytest_cache_assert._check_assert.differ.DiffResults","title":"DiffResults","text":"<p>         Bases: <code>BaseModel</code></p> <p>Result from calculating the diff.</p> Source code in <code>pytest_cache_assert/_check_assert/differ.py</code> <pre><code>class DiffResults(BaseModel):\n\"\"\"Result from calculating the diff.\"\"\"\nresults: Dict  # type: ignore[type-arg]\n@beartype\ndef to_dict(self) -&gt; Dict:  # type: ignore[type-arg]\nreturn self.results\n@beartype\ndef append(self, assert_rule: AssertRule, result: Dict) -&gt; None:  # type: ignore[type-arg]\nself.results[f'For {assert_rule}'] = result\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/differ/#pytest_cache_assert._check_assert.differ-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/_check_assert/differ/#pytest_cache_assert._check_assert.differ.diff_with_rules","title":"diff_with_rules","text":"<pre><code>diff_with_rules(*, old_dict, new_dict, assert_rules)\n</code></pre> <p>Determine the differences between two dictionaries.</p> PARAMETER DESCRIPTION <code>old_dict</code> <p>old dictionary (typically cached one)</p> <p> TYPE: <code>T_DIFF</code> </p> <code>new_dict</code> <p>new dictionary (typically test data)</p> <p> TYPE: <code>T_DIFF</code> </p> <code>assert_rules</code> <p>list of assert rules to ignore certain differences</p> <p> TYPE: <code>List[AssertRule]</code> </p> RETURNS DESCRIPTION <code>DiffResults</code> <p>Diff Object</p> <p> TYPE: <code>DiffResults</code> </p> Source code in <code>pytest_cache_assert/_check_assert/differ.py</code> <pre><code>@beartype\ndef diff_with_rules(*, old_dict: T_DIFF, new_dict: T_DIFF, assert_rules: List[AssertRule]) -&gt; DiffResults:\n\"\"\"Determine the differences between two dictionaries.\n    Args:\n        old_dict: old dictionary (typically cached one)\n        new_dict: new dictionary (typically test data)\n        assert_rules: list of assert rules to ignore certain differences\n    Returns:\n        DiffResults: Diff Object\n    \"\"\"\nkey_str = 'str'\nkey_re = 'regex'\ncollector: Dict[str, List[Union[str, Pattern[str]]]] = {key_str: [], key_re: []}\nfor ar in assert_rules:\ncollector[key_re if ar.is_regex() else key_str].append(ar.pattern)\ndiff_result = _raw_diff(\nold_dict=old_dict,\nnew_dict=new_dict,\nexclude_paths=collector[key_str],\nexclude_regex_paths=collector[key_re],\n)\nfor ar in assert_rules:\npaths = []\nfor data_set in [old_dict, new_dict]:\nds = DeepSearch(data_set, ar.pattern, use_regexp=ar.is_regex())\npaths.extend([*ds.get('matched_paths', {})])\nfor pth in set(paths):\nnew_value, old_value = NotFound(), NotFound()\nwith suppress(KeyError):\nold_value = extract(old_dict, pth)\nwith suppress(KeyError):\nnew_value = extract(new_dict, pth)\nif not ar.func(old_value, new_value):\ndiff_result.append(ar, {'old_value': old_value, 'new_value': new_value})\nreturn diff_result\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/","title":"error_message","text":"<p>Generate nice error messages.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message.NoCacheError","title":"NoCacheError","text":"<p>         Bases: <code>FileNotFoundError</code></p> <p>Custom Assertion when no cached data is available for read.</p> Source code in <code>pytest_cache_assert/_check_assert/error_message.py</code> <pre><code>class NoCacheError(FileNotFoundError):\n\"\"\"Custom Assertion when no cached data is available for read.\"\"\"\n...\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message.RichAssertionError","title":"RichAssertionError","text":"<p>         Bases: <code>AssertionError</code></p> <p>Custom AssertionError with additional <code>error_info</code>.</p> Source code in <code>pytest_cache_assert/_check_assert/error_message.py</code> <pre><code>class RichAssertionError(AssertionError):\n\"\"\"Custom AssertionError with additional `error_info`.\"\"\"\ndef __init__(self, *args: Any, error_info: Any = None) -&gt; None:\n\"\"\"Store the error_info for later access.\"\"\"  # noqa: DAR101\nsuper().__init__(*args)\nself.error_info = error_info\n@classmethod\ndef create_message(\ncls, test_data: Any, cached_data: Any, path_cache_file: Path,\ndiff_results: DiffResults,\n) -&gt; str:\n\"\"\"Create the error message.\n        Args:\n            test_data: the test data\n            cached_data: the cached data\n            path_cache_file: the path to the cache file\n            diff_results: the diff results\n        Returns:\n            str: pleasant error message\n        \"\"\"\n@beartype\ndef fmt_line(prefix: str, data: Any) -&gt; str:\nindented_data = ('\\n' + ' ' * len(prefix)).join(pformat(data).split('\\n'))\nreturn f'{prefix}{indented_data}'\ndiff_prefix = '&gt; Differences: '\nline_diff = fmt_line(diff_prefix, diff_results.to_dict())\nfile_diff = f'\\n&gt; Found differences with: {path_cache_file}' if path_cache_file else ''\nreturn f'{file_diff}\\n{line_diff}\\n'\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message.RichAssertionError-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message.RichAssertionError.__init__","title":"__init__","text":"<pre><code>__init__(*args, error_info=None)\n</code></pre> <p>Store the error_info for later access.</p> Source code in <code>pytest_cache_assert/_check_assert/error_message.py</code> <pre><code>def __init__(self, *args: Any, error_info: Any = None) -&gt; None:\n\"\"\"Store the error_info for later access.\"\"\"  # noqa: DAR101\nsuper().__init__(*args)\nself.error_info = error_info\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/error_message/#pytest_cache_assert._check_assert.error_message.RichAssertionError.create_message","title":"create_message  <code>classmethod</code>","text":"<pre><code>create_message(test_data, cached_data, path_cache_file, diff_results)\n</code></pre> <p>Create the error message.</p> PARAMETER DESCRIPTION <code>test_data</code> <p>the test data</p> <p> TYPE: <code>Any</code> </p> <code>cached_data</code> <p>the cached data</p> <p> TYPE: <code>Any</code> </p> <code>path_cache_file</code> <p>the path to the cache file</p> <p> TYPE: <code>Path</code> </p> <code>diff_results</code> <p>the diff results</p> <p> TYPE: <code>DiffResults</code> </p> RETURNS DESCRIPTION <code>str</code> <p>pleasant error message</p> <p> TYPE: <code>str</code> </p> Source code in <code>pytest_cache_assert/_check_assert/error_message.py</code> <pre><code>@classmethod\ndef create_message(\ncls, test_data: Any, cached_data: Any, path_cache_file: Path,\ndiff_results: DiffResults,\n) -&gt; str:\n\"\"\"Create the error message.\n    Args:\n        test_data: the test data\n        cached_data: the cached data\n        path_cache_file: the path to the cache file\n        diff_results: the diff results\n    Returns:\n        str: pleasant error message\n    \"\"\"\n@beartype\ndef fmt_line(prefix: str, data: Any) -&gt; str:\nindented_data = ('\\n' + ' ' * len(prefix)).join(pformat(data).split('\\n'))\nreturn f'{prefix}{indented_data}'\ndiff_prefix = '&gt; Differences: '\nline_diff = fmt_line(diff_prefix, diff_results.to_dict())\nfile_diff = f'\\n&gt; Found differences with: {path_cache_file}' if path_cache_file else ''\nreturn f'{file_diff}\\n{line_diff}\\n'\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/","title":"serializer","text":"<p>Implement a serializer for caching data to and from version controlled files.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer-attributes","title":"Attributes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.Unconvertable","title":"Unconvertable","text":"<p>         Bases: <code>ValueError</code></p> <p>Custom Error to indicate conversion failure.</p> Source code in <code>pytest_cache_assert/_check_assert/serializer.py</code> <pre><code>class Unconvertable(ValueError):\n\"\"\"Custom Error to indicate conversion failure.\"\"\"\n...\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.dumps","title":"dumps","text":"<pre><code>dumps(obj, sort_keys=False, indent=0)\n</code></pre> <p>Serialize object to str.</p> PARAMETER DESCRIPTION <code>obj</code> <p>data to serialize</p> <p> TYPE: <code>Any</code> </p> <code>sort_keys</code> <p>if True, order keys before serializing</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>indent</code> <p>indent for pretty-printing. Default is no extra whitespace</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>str</code> <p>serialized data</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>Unconvertable</code> <p>when serialization fails</p> Source code in <code>pytest_cache_assert/_check_assert/serializer.py</code> <pre><code>@beartype\ndef dumps(obj: Any, sort_keys: bool = False, indent: int = 0) -&gt; str:\n\"\"\"Serialize object to str.\n    Args:\n        obj: data to serialize\n        sort_keys: if True, order keys before serializing\n        indent: indent for pretty-printing. Default is no extra whitespace\n    Returns:\n        str: serialized data\n    Raises:\n        Unconvertable: when serialization fails\n    \"\"\"\ntry:\nreturn json.dumps(obj, sort_keys=sort_keys, indent=indent or None, cls=_CacheAssertSerializer)\nexcept Unconvertable as exc:\nraise Unconvertable(f'Conversion error. Try specifying new converters in AssertConfig to fix: {exc}') from exc\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.loads","title":"loads","text":"<pre><code>loads(raw)\n</code></pre> <p>Deserialize arbitrary JSON data back to Python types.</p> PARAMETER DESCRIPTION <code>raw</code> <p>raw string JSON</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>T_DIFF</code> <p>DiffResults-safe data</p> <p> TYPE: <code>T_DIFF</code> </p> Source code in <code>pytest_cache_assert/_check_assert/serializer.py</code> <pre><code>@beartype\ndef loads(raw: str) -&gt; T_DIFF:\n\"\"\"Deserialize arbitrary JSON data back to Python types.\n    Args:\n        raw: raw string JSON\n    Returns:\n        T_DIFF: DiffResults-safe data\n    \"\"\"\nreturn json.loads(raw)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.make_diffable","title":"make_diffable","text":"<pre><code>make_diffable(data)\n</code></pre> <p>Convert raw object to diffable types for assertion checks.</p> PARAMETER DESCRIPTION <code>data</code> <p>data to serialize</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>T_DIFF</code> <p>DiffResults-safe data</p> <p> TYPE: <code>T_DIFF</code> </p> Source code in <code>pytest_cache_assert/_check_assert/serializer.py</code> <pre><code>@beartype\ndef make_diffable(data: Any) -&gt; T_DIFF:\n\"\"\"Convert raw object to diffable types for assertion checks.\n    Args:\n        data: data to serialize\n    Returns:\n        T_DIFF: DiffResults-safe data\n    \"\"\"\nreturn loads(dumps(data))\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.pretty_dumps","title":"pretty_dumps","text":"<pre><code>pretty_dumps(obj)\n</code></pre> <p>Serialize object to a pretty-printable str.</p> PARAMETER DESCRIPTION <code>obj</code> <p>data to serialize</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>str</code> <p>serialized data</p> <p> TYPE: <code>str</code> </p> Source code in <code>pytest_cache_assert/_check_assert/serializer.py</code> <pre><code>@beartype\ndef pretty_dumps(obj: Any) -&gt; str:\n\"\"\"Serialize object to a pretty-printable str.\n    Args:\n        obj: data to serialize\n    Returns:\n        str: serialized data\n    \"\"\"\nreturn dumps(obj, sort_keys=True, indent=2).strip() + '\\n'\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/serializer/#pytest_cache_assert._check_assert.serializer.register_user_converters","title":"register_user_converters","text":"<pre><code>register_user_converters(converters)\n</code></pre> <p>Register the user-specified converters.</p> Source code in <code>pytest_cache_assert/_check_assert/serializer.py</code> <pre><code>@beartype\ndef register_user_converters(converters: List[Converter]) -&gt; None:\n\"\"\"Register the user-specified converters.\"\"\"\nfor converter in converters:\n_CONVERTERS.register(converter.types, converter.func)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/validator/","title":"validator","text":"<p>Override the default validator for determining differences with the cached data.</p>"},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator-classes","title":"Classes","text":""},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator.DictDiffValidator","title":"DictDiffValidator","text":"<p>Default Validator.</p> Source code in <code>pytest_cache_assert/_check_assert/validator.py</code> <pre><code>class DictDiffValidator:\n\"\"\"Default Validator.\"\"\"\n@staticmethod\n@beartype\ndef assertion(\n*, test_data: Any, cached_data: Any, assert_rules: List[AssertRule], path_cache_file: Optional[Path] = None,\n) -&gt; None:\n\"\"\"Validate test data against cached data.\n        Args:\n            test_data: data to compare\n            cached_data: data to compare\n            assert_rules: list of assert rules to apply\n            path_cache_file: optional Path to the cached data\n        Raises:\n            RichAssertionError: if any assertion comparison fails\n        \"\"\"\ndiff_results = diff_with_rules(old_dict=cached_data, new_dict=test_data, assert_rules=assert_rules or [])\nif diff_results.to_dict():\nkwargs = {\n'test_data': test_data,\n'cached_data': cached_data,\n'path_cache_file': path_cache_file,\n'diff_results': diff_results,\n}\nraise RichAssertionError(RichAssertionError.create_message(**kwargs), error_info=kwargs)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator.DictDiffValidator-functions","title":"Functions","text":""},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator.DictDiffValidator.assertion","title":"assertion  <code>staticmethod</code>","text":"<pre><code>assertion(*, test_data, cached_data, assert_rules, path_cache_file=None)\n</code></pre> <p>Validate test data against cached data.</p> PARAMETER DESCRIPTION <code>test_data</code> <p>data to compare</p> <p> TYPE: <code>Any</code> </p> <code>cached_data</code> <p>data to compare</p> <p> TYPE: <code>Any</code> </p> <code>assert_rules</code> <p>list of assert rules to apply</p> <p> TYPE: <code>List[AssertRule]</code> </p> <code>path_cache_file</code> <p>optional Path to the cached data</p> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>RichAssertionError</code> <p>if any assertion comparison fails</p> Source code in <code>pytest_cache_assert/_check_assert/validator.py</code> <pre><code>@staticmethod\n@beartype\ndef assertion(\n*, test_data: Any, cached_data: Any, assert_rules: List[AssertRule], path_cache_file: Optional[Path] = None,\n) -&gt; None:\n\"\"\"Validate test data against cached data.\n    Args:\n        test_data: data to compare\n        cached_data: data to compare\n        assert_rules: list of assert rules to apply\n        path_cache_file: optional Path to the cached data\n    Raises:\n        RichAssertionError: if any assertion comparison fails\n    \"\"\"\ndiff_results = diff_with_rules(old_dict=cached_data, new_dict=test_data, assert_rules=assert_rules or [])\nif diff_results.to_dict():\nkwargs = {\n'test_data': test_data,\n'cached_data': cached_data,\n'path_cache_file': path_cache_file,\n'diff_results': diff_results,\n}\nraise RichAssertionError(RichAssertionError.create_message(**kwargs), error_info=kwargs)\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator.ValidatorType","title":"ValidatorType","text":"<p>         Bases: <code>Protocol</code></p> <p>Validator Interface.</p> Source code in <code>pytest_cache_assert/_check_assert/validator.py</code> <pre><code>@runtime_checkable\nclass ValidatorType(Protocol):\n\"\"\"Validator Interface.\"\"\"\n@staticmethod\ndef assertion(\n*, test_data: Any, cached_data: Any, assert_rules: List[AssertRule], path_cache_file: Optional[Path] = None,\n) -&gt; None:\n...\n</code></pre>"},{"location":"reference/pytest_cache_assert/_check_assert/validator/#pytest_cache_assert._check_assert.validator-functions","title":"Functions","text":""}]}